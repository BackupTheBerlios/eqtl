#!/usr/bin/perl -w

TEMPLATEWARNINGHASH

=head1 NAME

prepareRqtlInputData.pl - transforms expresssion data and genotype data into single files for job input

=head1 SYNOPSIS

Called from the web server. Needs identifier 'probesetid' to denote the gene to be investigated.

=head1 DESCRIPTION

Except for a change in the interpretation of covariates, i.e. from interacting to additive,
every computation needs a different input. This input is prepared by this script, which
involves the reading of all input data by a web server, to subsequently generate the
right combinations upon request.

The script does not perform any selection of workunits, or reports on the submission,
it only prepares the data.

=head1 AUTHORS

Jan Kolbaum with some contribution by Steffen Moeller <moeller@inb.uni-luebeck.de> and Benedikt Bauer.
2008-08-27

=cut

use CGI::Carp qw(fatalsToBrowser);
use strict;
use FCGI;
use Cwd;

my $request = FCGI::Request();

my %data = 	(
		'genofile' => 'GENOFILE',
		'phenofile' => 'PHENOFILE',
		'scorefile' => 'SCOREFILE'
		);

my $base="BASEDIR";
my $database="URLCSVDEPOT";

#open files, read them to memory, close them
open(getFrom, $base.$database.$data{'phenofile'}) || open(getFrom,$database.$data{'phenofile'}) || open(getFrom,$data{'phenofile'}) || die "No such pheno-file at $database$data{'phenofile'}, executed from ".cwd().": $@";		#insert-file will  be expaneded by probe-column

my %probe2line;
while( <getFrom> ){
        my $l = $_;
	my ($p,$_) = split( /,/,$l);
	$probe2line{$p}=$l;
}
		
#open(getFrom, $database.$data{'phenofile'}) || open(getFrom,$data{'phenofile'}) || die "No such pheno-file at ".$database.$data{'phenofile'}.cwd().$@;		#insert-file will  be expaneded by probe-column
#	open(INSERT, "$base$database$data{'genofile'}") || open(getFrom,$data{'genofile'}) || die "No such gene-file at $database$data{'genofile'}: $@";		#open the file wich contains probe-data
my @insertionFile;
open(INSERT, $base.$database.$data{'genofile'}) || open(INSERT,$database.$data{'genofile'}) || open(INSERT,$data{'genofile'}) || die "No such gene-file at ".$database.$data{'genofile'}.": ".$@;		#open the file wich contains probe-data

while(<INSERT>){
	chomp;
	push (@insertionFile,$_);
}
close(INSERT);


while (FCGI::accept >= 0) {

	print	"Content-type: text/plain\n\n";					#sign page-type as plain

	#check if argument has been given
	my @params = split(/&/, $ENV{'QUERY_STRING'});
	my $probeID;

	foreach my $key (@params){
		if( $key =~ m/probesetid/ ){
			my @tmp = split(/=/,$key);
			$probeID = $tmp[1];
		}
	}
	
	if( !defined( $probeID ) && $#ARGV == 2 ){
		$probeID = $ARGV[2];				#id of probset to insert
	}elsif( !defined( $probeID ) && $#ARGV == 0 ){
		$probeID = $ARGV[0];				#id of probset to insert
	}

	
	if( !defined( $probeID) ){
		print "Usage when accessed via web address :\t<url>?probesetid=\"probesetid\"\n",
		      "      When accessed via command line:\tinsertProbe_online.pl gene-file pheno-file probesetid\n";
		exit(-1);
	}

#	die $database.$data{'phenofile'};#."\n".cwd()."\n";

	my $sep=",";
	if( $probeID eq 'none' ){
		my $lastElement = $#insertionFile;			
		for( my $i=0; $i<=$lastElement; $i++ ){		#here the later returned file is splitted up to insert probeinformations, using insert subroutine
			unless (2 == $i) {
				print $insertionFile[$i]."\n";
			}
		}
	}else{
		my @line = split(/PHENOFIELDSEP/,$probe2line{$probeID});
		
		if( !@line ){ die "No such probesetID: $probeID"; }
		
		my $lastIndex = $#insertionFile;			
		for( my $i=0; $i<=$lastIndex; $i++ ){
			my @iline = split(/GENOFIELDSEP/, $insertionFile[$i]);
								# always take the first two fields
			my $ret  =      $iline[0];
			$ret    .= $sep.$iline[1];
			
								#here the later returned file is splitted up to insert probeinformations, using insert subroutine
			if( $i==0) 	# column names
			{ 				# as some lines have to be omitted, some indexshifting is required
				$ret .= $sep . $line[$i];
			}
			elsif( $i > 2 ){
				# Marker data
				 $ret .= $sep . $line[$i-2];
			}
			elsif( 1==$i # Chromosomes
				or
			       2==$i # Centimorgan
			){
				$ret .= $sep;
			}
			for( my $j=2; $j<=$#iline; $j++ ){				#reassamble the (now exanded) line
				$ret .=  $sep.$iline[$j];
			}
			#if ( -z "$ret" ) {
			#	print STDERR "ret is empty.\n";
			#}
			print $ret."\n";
		}
	}
}
