#!/usr/bin/perl -w

TEMPLATEWARNINGHASH

=head1 NAME

getRscript.pl - should better be named 'prepare R/qtl input data'

=head1 SYNOPSIS

getRscript.pl

In the regular installation, this script is called from the web server
but it may also be invoked from the shell e.g. for testing purposes.

=head1 DESCRIPTION

Every workunit gets a tailored R script to execute. This Perl script
prepares it.

=cut

use strict;

use FCGI;
use CGI::Carp qw(fatalsToBrowser);
use Cwd;

use Pod::Usage;
use Getopt::Long;

my $help;
my $man;
my $verbose;

GetOptions("verbose" =>\$verbose, "help" => \$help, "man" => \$man)
	or die "Could not parse options: $@.\n";

pod2usage(-verbose => 2) if $man or $help;

my $request = FCGI::Request();


# gobal prior known variables

my $src="PHENOFILE";		#the pheno-file
my $base="BASEDIR";		#base directory of this project
my $database="URLCSVDEPOT";	#storage cotaining miscellaneous data
my $covbase="CSVDATABASEGENOFILE";
my $phenocol;


=head2 errorMessage

Upon error, the script should not end, unless if the error is completely
erroneous and indicates that the whole setup is broken. The error
detected is only passed to the script, which will then take appropriate
action.

In the current implementation, the client will terminate itself. Some
better idea is needed, still.

=cut

sub errorMessage($) {
	my $msg = shift;
	# the error appears as a comment in the text, which should always work
	print STDOUT "# $msg\n";
	# the error appears as an output of the program, which might or might not work.
	print STDOUT "cat(\"$msg\")\n";
	# the error appears as an error in the apache.log, which should work
	print STDERR "cat(\"$msg\")\n";

	# tell the client to exit
	print "q(save=\"no\")\n"
}


=head2 main loop

The script is prepared for FastCGI. A series of parameters may be passed

=cut

while (FCGI::accept >= 0) {

	my @params;
	my @covars;
	my $pc;
	my $mode = 'scanone';


=over 4

=item perms

the number of permutations, predefined by the PERMS configuration parameter

=item alpha

the quantile in the permutations against which the real LOD score competes, 
predefined by the configuration parameter ALPHA

=item method

a parameter passed to R/qtl, set to 'hk'.

=item cov_meth

a parameter passed to R/qtl, set to 'int'.

=item d

the directory at which (on the client side) the results are stored, preset by RECALCDIR

=item h

preset by RECALCHOST

=item p

preset by RECALCPORT

=back

=cut

	my %execParams = (
				'perms' => PERMS,
				'alpha' => ALPHA,
				'stepsSO' => STEPSSO,
				'stepsST' => STEPSST,
				'errorP' => ERRORP,
				'draws' => DRAWS,
				'threshold' => THRESHOLD,
				'applyLog2' => "APPLYLOG2",
				'method' => 'hk',
				'cov_meth' => 'int',
				'd'=>'RECALCDIR',
				'h'=>'RECALCHOST',
				'p'=>'RECALCPORT'
	);


	#
	# Read parameters from website
	#

	if (exists($ENV{'QUERY_STRING'})) {

		# 
		# The early setting of the content type ensures that the error
		# messages correctly appear on the web page. Otherwise they
		# are possibly not forwarded to the end user.
		#
		# This conditional setting shall help to render the output
		# directly executable even if not produced by a web server
		#

		print "Content-type: text/plain\n\n";

		#
		# Assignment of arguments to internal presentation
		#
		@params = split(/&/, $ENV{'QUERY_STRING'});
	}
	else {
		print "#!/usr/bin/r\n";

		print STDERR "# getRscript.pl: Presuming to be run from the command line - testing only.\n";
		@params=(
			"covar=EAE",
			"probesetid=31",
			"phenocol=PHENOCOL",
			"mode=scanone",
			"applyLog2=APPLYLOG2"
		);
	}

	print <<EOGENERATEDFILEWARNING;

#			 This file is generated by the Perl script described
#			 in "website/getRscript.pl.template". It is generated
#			 individually for every work unit.

EOGENERATEDFILEWARNING
	
=head3 Probeset ID

Every QTL is for a single molecular effect only. The molecular effect is determined via the probeset ID,
borrowing the term from Affymetrix. No logics have yet been implemented to inspect multime molecular
probes at once. This would be of interest for inspecting probes individually or to see another gene's
expression as a covariate.

=cut

	my $probeID;
	
	# get value to params
	# [ covar=X1,X2,X3,... | probesetid=X | perms=X | alpha=X | steps=X | errorP=X | draws=X | threshold=X | method=X ]
	# at parameter covar  use FCGI;X1 will always be main covariate
	foreach my $paramElement (@params){
		my @value = split(/=/,$paramElement);
		if( $value[0] =~ m/covar/ ){
			if( $value[1] !~ m/none/ ) {
				@covars = split( ",", $value[1] );
			}
			else {
				@covars = ();
			}
		}elsif( $value[0] =~ m/probesetid/ ){
			$probeID = $value[1];
		}elsif( $value[0] =~ m/phenocol/ ){
			$pc = $value[1];
		}elsif( $value[0] =~ m/mode/ ){
			$mode = $value[1];
			if( $mode ne 'scanone' && $mode ne 'scantwo' ){
				errorMessage("Wrong value at parameter mode, only scanone or scantwo are allowed! "
				            ."You used '$mode'\n");
				next;
			}
		}else{
			$execParams{$value[0]}=$value[1];
		}
	}

	#
	# Stop if we don't have a probeID
	#

	if( !defined( $probeID ) ){
		errorMessage("getRscript.pl: Spotted probeID to be undefined, pass probesetid=10 as extra argument.");
		next;
	}

	#
	# The 'keyData' variable determines the file name and shall be easily parseable 
	# to retrieve the most essential information directly from it.
	#

	my $keyData = '';
	if( defined( $probeID ) ){
		$probeID =~ s/\n//;
		$keyData = $mode."_".$probeID."_".$execParams{'threshold'}."_".$execParams{'perms'};
		if( @covars ){
			$keyData = "$keyData" . "_(".join(",",@covars).")";
		}else{
			$keyData = "$keyData"."_(none)";
		}
	}

=head3 Phenotype Column 'pc'
	
'pc' denotes the column at which to expect the phenotype that should be
modelled. It should be set to 3 for regular expression QTL analyses,
 pointing to the expression level with the individual's number and ID
occupying the first two columns. This will different for every project.

=cut

	if( !defined($pc) ){
		if( $probeID eq 'none' ){
			errorMessage("getRscript.pl: demanding classical QTL analyses, not yet implemented (probeID='none').");
			next;
		}else{
			errorMessage("getRscript.pl: column with major phenotype "
				."(most likely the expression level) "
				."not indicated (probeID='$probeID')."
				." "
				."You may want to add &phenocol=PHENOCOL to the URL."
				);
			next;
		}
	}else{
		$phenocol = "pheno.col=$pc,";
	}
	
	my @rScript;
	my $covStr = '';


=head3 Covariates

Covariates can either look like cov_int, cov_add or cov 
cov_int means this covariate is use interactiv
cov_add uses this covariate just additive
cov uses this covariate as given in cov_meth, either int or add

=cut
	
	my @covars_int = ();
	my @covars_add = ();
	if( @covars ){
		foreach my $cov (@covars){
			if($cov =~ s/_int//){
			   push(@covars_int, $cov);
			   push(@covars_add, $cov);
			}
			elsif($cov =~ s/_add//){
			   push(@covars_add, $cov);
			}
			else{
			   if( $execParams{'cov_meth'} eq 'int' ){
			      push(@covars_int, $cov);
			      push(@covars_add, $cov);
			      	
			   }
			   elsif( $execParams{'cov_meth'} eq 'add' ){
			      push(@covars_add, $cov);
			   }
			   else{
                              errorMessage($execParams{'cov_meth'}." is not a valid option for cov_meth [add (=additive) | int (=interactiv)]");
			      next;
                           } 
			}
		}

		if(@covars_add){
			if(@covars_int){
				$covStr = ", addcov=cov_add, intcov=cov_int";
			}
			else{
				$covStr = ", addcov=cov_add";
			}
		}	
	}
	

	my $steps;
	if( $mode eq 'scanone' ){ $steps = $execParams{'stepsSO'}; }
	else{ $steps = $execParams{'stepsST'}; }

=head2 writeToDisk - R function

This function writes the result files. It ensures that the right file
is written to and that the results are easily parseable from the
Perl script that is performing the upload to the expression QTL
database.

=cut
	my $writeToDisk = <<EOWRITETODISK;

# constants 
probeID<-"$probeID"
method <-"$execParams{'method'}"


# function to determine quantiles for the scantwo objects
quantile.scantwoperm<-function(perms,quantiles) {
  sapply(perms,function(X) quantile(X,quantiles))
}

# name of file that collects results of this workunit

my.file.name <- paste("$execParams{'d'}/$keyData.csv.gz",sep="")

# check if file exists and rename it if so
if (file.exists(my.file.name)) {
	file.rename(my.file.name, paste(my.file.name,SUFFFIXINDICATINGDOUBLETTE))
}

# function to store results
writeToDisk <- function( toWrite, row.names=TRUE, col.names=TRUE ){

	my.file <- gzfile(description=my.file.name, open = "a",
	                  encoding = getOption("encoding"), compression = 6)

	if ( is.list(toWrite) ) {
		#cat("*** DEBUG START*** Now I am printing a list.\\n")
		vert <- labels( toWrite )
		write.table( print(toWrite), file=my.file, append=TRUE )
		#cat("*** DEBUG END*** Now I am printing a list.\\n")
	} else if ( is.vector(toWrite) ) {
		#cat("*** DEBUG START*** Now I am printing a VECTOR.\\n")
		label <- labels( toWrite )
		if( label[1] != 1 ){
			# FIXME: clarify what Jan meant by label[1]!=1   Steffen
			write( paste(label,collapse=" , ",sep=""), file=my.file, append=TRUE )
		}
		write( paste(toWrite, collapse=" , ", sep=""), file=my.file, append=TRUE )
		#cat("*** DEBUG END*** Now I am printing a VECTOR.\\n")
	} else if ( is.matrix(toWrite) ) {
		write.table(toWrite,file=my.file,col.names=col.names,row.names=row.names,sep=",")
	} else if ( is.numeric(toWrite) ) {
		tmplabel <- labels( toWrite )
		label = tmplabel[1]
		for( i in 2:length(tmplabel)){
			label <- paste( label, tmplabel[i], sep="," )
		}
		write( label, file=my.file, append=TRUE, sep="," )
		write( toWrite, file=my.file, append=TRUE, sep="," )
	} else {
		write( toWrite, file=my.file, append=TRUE, sep="," )
	}
	close( my.file )
}
EOWRITETODISK

	my $getDataUrl='URLGETDATA?probesetid='.$probeID.'&applyLog2='.$execParams{'applyLog2'}
			.'&score='.join(",",@covars); # this join causes the trouble
		# the score is not interpreted by URLGETDATA for the very moment
	my $getData = <<EOWRITETODISK;

cat("Fetching data from url '$getDataUrl'.\\n")

my.cross <- read.cross(	format="csv", dir="",
                       	file="$getDataUrl",
		        genotypes=RQTLREADCROSSGENOTYPES,
			alleles=RQTLREADCROSSALLELES,
			na.strings=RQTLREADCROSSNASTRINGS, convertXdata=TRUE )
my.cross <- calc.genoprob( my.cross, step=$steps, error.prob=$execParams{'errorP'} )

EOWRITETODISK

	if( $mode eq 'scantwo' ){
		$getData .= <<EOWRITETODISK;
my.cross <- sim.geno(my.cross, step=$steps, n.draws=$execParams{'draws'})
EOWRITETODISK
	}

	my $printCov_add ="";
	if( @covars_add ){
		my $concat = "\"".join("\",\"",@covars_add)."\"";
		# The covariate 'none' should have been removed before to yield
		# an empty list of covariates.
		$printCov_add = <<EOWRITETODISK;
cov_add <- my.cross\$pheno[,c($concat)]
EOWRITETODISK
	}
	my $printCov_int ="";
	if( @covars_int ){
		my $concat_int = "\"".join("\",\"",@covars_int)."\"";
		# The covariate 'none' should have been removed before to yield
		# an empty list of covariates.
		$printCov_int = <<EOWRITETODISK;
cov_int <- my.cross\$pheno[,c($concat_int)]
EOWRITETODISK
	}

	my $writePermutations;
	my $tryPermutations = <<EOWRITETODISK;

my.$mode.S <- $mode( my.cross, $phenocol method="$execParams{'method'}"$covStr, verbose=FALSE )

# initial presumption on the eQTLs found being acceptable
acceptable <- T
my.success<-0
perms.done<-0
my.max<-max(my.$mode.S\$lod)

# if acceptable, perform check on maximal LOD found
if (acceptable) {
	if (THRESHOLD>my.max) {
		cat(paste("Rejected: max(lod)=",my.max,"<THRESHOLD\\n",sep=""))
		acceptable <- F
	} else {
		cat(paste("\\nRegular LOD score achieved ($mode) : ",my.max,"\\n",sep=""))
	}
}



EOWRITETODISK

	my $permutationSuccessBlock;

	if ($execParams{'perms'} > 0) {

		$tryPermutations .= <<EOWRITETODISK;

# if still acceptable, perform permutation tests
if (acceptable) {
	# list of pairs identifying the number of permutations and the quantils that is to be reached
	perm.checks<-list(c(  10,                1-0.5),
	                  c(  25,                1-$execParams{'alpha'}-0.2),
			  c( 100,                1-$execParams{'alpha'}-0.02),
			  c($execParams{perms}/4,1-$execParams{'alpha'}),
			  c($execParams{perms}/2,1-$execParams{'alpha'}),
			  c($execParams{perms}  ,1-$execParams{'alpha'}))

	# iteration over partial permutations, the permutation results are stored in perm.collection
	#print(perm.checks)
	perm.collection<-NULL
	perm.no.prev.round<-0
	for(X in perm.checks) {
		cat( paste("\\n",date(),": Performing ",X[1]," permutations, checking against quantile 1-",X[2],"\\n",sep="") )
		my.$mode.P <- $mode( my.cross, $phenocol method="$execParams{'method'}"$covStr, n.perm=X[1]-perm.no.prev.round, verbose=FALSE )
		if (is.null(perm.collection)) {
			perm.collection <- my.$mode.P
		} else {
			perm.collection <- rbind(perm.collection,my.$mode.P)
		}

		my.quants <- summary(perm.collection,alpha=(1-X[2]))
		perms.done<-X[1]
EOWRITETODISK

		if( $mode eq 'scantwo' ) {
			$tryPermutations .= <<EOWRITETODISK;
		thresh<-my.quants[['full']][1]
EOWRITETODISK
		}
		else {
			$tryPermutations .= <<EOWRITETODISK;
		thresh<-my.quants[1,'lod']
EOWRITETODISK
		} # else of if (scantwo)

		$tryPermutations .= <<EOWRITETODISK;
		cat("Determined the following quantiles:\\n")
		print(my.quants)
		cat("Threshold: ",thresh,"\\n")
		if( my.max < thresh ){
			print( paste(date(), ": failed assertion max(lod)>=quantile:  ", my.max,">=", thresh, " <=> FALSE\\n",sep="") )
			acceptable <- FALSE
			break;
		}
		perm.no.prev.round<-X[1]
	}

	if (acceptable) {
		my.$mode.S.P.summary <- summary( my.$mode.S, perms=perm.collection, alpha=$execParams{'alpha'}, pvalues=TRUE)
		my.success <- length(my.$mode.S.P.summary[[1]])
		my.quants <- quantile(perm.collection, c(0,0.1,0.25,0.5,0.75,0.9,0.95,0.99,1))
	} # if acceptable after having done the permutation tests
} # if acceptable to enter permutation tests

EOWRITETODISK


		$writePermutations = <<EOWRITETODISK;

if (acceptable) {

	# write significant SNPs evaluated by permutations for their p-values
	writeToDisk( "<SUMMARY::$mode.S.P>" )
	writeToDisk( my.$mode.S.P.summary )
	writeToDisk( "</SUMMARY::$mode.S.P>" )

	# write quantiles of permutations
	writeToDisk( "<SUMMARY::quants>" )
	writeToDisk( my.quants )
	writeToDisk( "</SUMMARY::quants>" )

	# write raw data of permutations
	writeToDisk( "<DATA::$mode.P>" )
	writeToDisk( perm.collection, row.names=FALSE )
	writeToDisk( "</DATA::$mode.P>" )

}

EOWRITETODISK


	} # if ($execParams{'perms'})
	else {
		# not executed in production, but handy for debugging
		$tryPermutations .= "my.$mode.S.summary <- summary( my.$mode.S, threshold=".$execParams{'threshold'}." )\n";
	} # if-else ($execParams{'perms'})

	$writePermutations .= <<EOWRITETODISK;

if (acceptable) {
	# write plain results of $mode
	writeToDisk( "<DATA::$mode.S>" )
	writeToDisk( my.$mode.S )
	writeToDisk( "</DATA::$mode.S>" )
}
EOWRITETODISK


	if (0) {
	#FIXME: need way to write away warning and reset them
		$writePermutations .= <<EOWRITETODISK;
writeToDisk( "<WARNINGS>" )
writeToDisk( "</WARNINGS>" )
EOWRITETODISK
	}


	# status report - the first to parse

	my $c = join(",", @covars);
	my $toDisk = <<EOWRITETODISK;
writeToDisk( paste("<=$mode(",probeID,") success(",my.success,") method(",method,") permutations($execParams{'perms'}) threshold($execParams{'threshold'}) covariates($c) cov_meth($execParams{'cov_meth'}) alpha($execParams{'alpha'}) steps($steps) errorP($execParams{'errorP'}) draws($execParams{'draws'}) phenocol($pc) permsDone(",perms.done,") qtlversion(",qtlversion(),") R.Version(",R.Version()[["major"]],".",R.Version()[["minor"]],") platform(",R.Version()[["platform"]],")=>", sep="") )

EOWRITETODISK

	# system status - the final line, upload checks on end with </ENV>

	my $toEnd = <<EOWRITETODISK;

writeToDisk( "<ENV>" )
writeToDisk( Sys.info() )
writeToDisk( paste(\"Time: \",Sys.time(),\"\\n\",sep=\"\") )
writeToDisk( "</ENV>" )
EOWRITETODISK


	#
	# PRINTING OF FILE STARTS HERE
	#

	print "cat( \"<eqtl mode=\\\"$mode\\\" probe=\\\"$probeID\\\""
		." covars=\\\""    .join(",",@covars)."\\\""
		." covars_add=\\\"".join(",",@covars_add)."\\\""
		." covars_int=\\\"".join(",",@covars_int)."\\\""
		.">\\n\")\n";

	print $writeToDisk;

	my $status = "print( \"\" ) \n";

	if( @covars ){
		$status .= "print( \"!-using covariates: ".join(",",@covars)."\" )\n";
	}
	$status .= "print( \"!-mode:$mode\tprobe:$probeID\" )\n";

	$status .=  <<EOWRITETODISK;
cat( paste("!-",date(),"\\n",sep="") )
cat( "\\n" )
EOWRITETODISK

	print $getData;

	if( @covars_add ){
		print $printCov_add;
	}
	if( @covars_int ){
		print $printCov_int;
	}

	print $tryPermutations;

	print $status;

	print $toDisk;

	print $writePermutations;

	print $toEnd;

	print "cat(\"</eqtl>\\n\\n\")\n";

	print "\n".'"completed"'."\n"; 

	if (!exists($ENV{'QUERY_STRING'})) {
		print STDERR "getRscript.pl: Presuming to be run from the command line: exiting.\n";
		last;
	}

}

=head1 AUTHORS

Jan Kolbaum,
Ann-Kristin Grimm,
Steffen ME<ouml>ller <moeller@inb.uni-luebeck.de>

=head1 COPYRIGHT

University of LE<uuml>beck, 2008-2010

=cut
