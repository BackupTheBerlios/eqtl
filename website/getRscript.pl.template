#!/usr/bin/perl -w

TEMPLATEWARNINGHASH

=head1 NAME

getRscript.pl - should better be named 'prepare R/qtl input data'

=head1 SYNOPSIS

getRscript.pl

In the regular installation, this script is called from the web server
but it may also be invoked from the shell e.g. for testing purposes.

=head1 DESCRIPTION

Every workunit gets a tailored R script to execute. This Perl script
prepares it.

=cut

use strict;

use FCGI;
use CGI::Carp qw(fatalsToBrowser);
use Cwd;

my $request = FCGI::Request();


# gobal prior known variables

my $src="PHENOFILE";		#the pheno-file
my $base="BASEDIR";		#base directory of this project
my $database="URLCSVDEPOT";	#storage cotaining miscellaneous data
my $covbase="CSVDATABASEGENOFILE";
my $phenocol;


=head2 errorMessage

Upon error, the script should not end, unless if the error is completely
erroneous and indicates that the whole setup is broken. The error
detected is only passed to the script, which will then take appropriate
action.

In the current implementation, the client will terminate itself. Some
better idea is needed, still.

=cut

sub errorMessage($) {
	my $msg = shift;
	# the error appears as a comment in the text, which should always work
	print STDOUT "# $msg\n";
	# the error appears as an output of the program, which might or might not work.
	print STDOUT "cat(\"$msg\")\n";
	# the error appears as an error in the apache.log, which should work
	print STDERR "cat(\"$msg\")\n";

	# tell the client to exit
	print "q(save=\"no\")\n"
}

#
# A counter of the number of tasks prepared
#
my $probeCNT = 0;


=head2 main loop

The script is prepared for FastCGI. A series of parameters may be passed

=cut

while (FCGI::accept >= 0) {


	#
	# A counter of the number of tasks prepared
	#
	$probeCNT++;


	my @params;
	my @covars;
	my $pc;
	my $mode = 'scanone';


=over 4

=item perms

the number of permutations, predefined by the PERMS configuration parameter

=item alpha

the quantile in the permutations against which the real LOD score competes, 
predefined by the configuration parameter ALPHA

=item method

a parameter passed to R/qtl, set to 'hk'.

=item cov_meth

a parameter passed to R/qtl, set to 'int'.

=item d

the directory at which (on the client side) the results are stored, preset by RECALCDIR

=item h

preset by RECALCHOST

=item p

preset by RECALCPORT

=back

=cut

	my %execParams = (
				'perms' => PERMS,
				'alpha' => ALPHA,
				'stepsSO' => STEPSSO,
				'stepsST' => STEPSST,
				'errorP' => ERRORP,
				'draws' => DRAWS,
				'threshold' => THRESHOLD,
				'method' => 'hk',
				'cov_meth' => 'int',
				'd'=>'RECALCDIR',
				'h'=>'RECALCHOST',
				'p'=>'RECALCPORT'
	);


	#
	# Read parameters from website
	#

	if (exists($ENV{'QUERY_STRING'})) {

		# 
		# The early setting of the content type ensures that the error
		# messages correctly appear on the web page. Otherwise they
		# are possibly not forwarded to the end user.
		#
		# This conditional setting shall help to render the output
		# directly executable even if not produced by a web server
		#

		print "Content-type: text/plain\n\n";

		#
		# Assignment of arguments to internal presentation
		#
		@params = split(/&/, $ENV{'QUERY_STRING'});
	}
	else {
		print "#!/usr/bin/r\n";

		print STDERR "# getRscript.pl: Presuming to be run from the command line - testing only.\n";
		@params=(
			"covar=EAE",
			"probesetid=31",
			"phenocol=PHENOCOL",
			"mode=scanone"
		);
	}
	
	#
	# probe set ID of gene to be analysed for controlling loci
	#

	my $probeID;
	
	# get value to params
	# [ covar=X1,X2,X3,... | probesetid=X | perms=X | alpha=X | steps=X | errorP=X | draws=X | threshold=X | method=X ]
	# at parameter covar  use FCGI;X1 will always be main covariate
	foreach my $paramElement (@params){
		my @value = split(/=/,$paramElement);
		if( $value[0] =~ m/covar/ ){
			if( $value[1] !~ m/none/ ) {
				@covars = split( ",", $value[1] );
			}
			else {
				@covars = ();
			}
		}elsif( $value[0] =~ m/probesetid/ ){
			$probeID = $value[1];
		}elsif( $value[0] =~ m/phenocol/ ){
			$pc = $value[1];
		}elsif( $value[0] =~ m/mode/ ){
			$mode = $value[1];
			if( $mode ne 'scanone' && $mode ne 'scantwo' ){
				errorMessage("Wrong value at parameter mode, only scanone or scantwo are allowed! "
				            ."You used '$mode'\n");
				next;
			}
		}else{
			$execParams{$value[0]}=$value[1];
		}
	}

	#
	# Stop if we don't have a probeID
	#

	if( !defined( $probeID ) ){
		errorMessage("getRscript.pl: Spotted probeID to be undefined, pass probesetid=10 as extra argument.");
		next;
	}

	#
	# The 'keyData' variable determines the file name and shall be easily parseable 
	# to retrieve the most essential information directly from it.
	#

	my $keyData = '';
	if( defined( $probeID ) ){
		$probeID =~ s/\n//;
		$keyData = $mode."_".$probeID."_".$execParams{'threshold'}."_".$execParams{'perms'};
		if( @covars ){
			$keyData = "$keyData" . "_(".join(",",@covars).")";
		}else{
			$keyData = "$keyData"."_(none)";
		}
	}
	
	#
	# 'pc' denotes the column at which to expect the phenotype that should be
	# modelled. It should be set to 3 for regular expression QTL analyses.
	#

	if( !defined($pc) ){
		if( $probeID eq 'none' ){
			errorMessage("getRscript.pl: demanding classical QTL analyses, not yet implemented (probeID='none').");
			next;
		}else{
			errorMessage("getRscript.pl: column with major phenotype "
				."(most likely the expression level) "
				."not indicated (probeID='$probeID')."
				." "
				."You may want to add &phenocol=PHENOCOL to the URL."
				);
			next;
			#$phenocol = "pheno.col=3,";
			#$pc = $probeID;
		}
	}else{
		$phenocol = "pheno.col=$pc,";
	}
	
	my @rScript;
	my $covStr = '';

	#
	#  Covariates can either look like cov_int, cov_add or cov 
	#  cov_int means this covariate is use interactiv
	#  cov_add uses this covariate just additive
	#  cov uses this covariate as given in cov_meth, either int or add
	
	my @covars_int = ();
	my @covars_add = ();
	if( @covars ){
		foreach my $cov (@covars){
			if($cov =~ s/_int//){
			   push(@covars_int, $cov);
			   push(@covars_add, $cov);
			}
			elsif($cov =~ s/_add//){
			   push(@covars_add, $cov);
			}
			else{
			   if( $execParams{'cov_meth'} eq 'int' ){
			      push(@covars_int, $cov);
			      push(@covars_add, $cov);
			      	
			   }
			   elsif( $execParams{'cov_meth'} eq 'add' ){
			      push(@covars_add, $cov);
			   }
			   else{
                              errorMessage($execParams{'cov_meth'}." is not a valid option for cov_meth [add (=additive) | int (=interactiv)]");
			      next;
                           } 
			}
		}

		if(@covars_add){
			if(@covars_int){
				$covStr = ", addcov=cov_add, intcov=cov_int";
			}
			else{
				$covStr = ", addcov=cov_add";
			}
		}	
	}
	

	my $steps;
	if( $mode eq 'scanone' ){ $steps = $execParams{'stepsSO'}; }
	else{ $steps = $execParams{'stepsST'}; }


	my $writeToDisk = <<EOWRITETODISK;
writeToDisk <- function( toWrite, row.names=TRUE, col.names=TRUE ){
	my.file <- gzfile(description=paste("$execParams{'d'}/$keyData.csv.gz",sep=""),
				open = "a", encoding = getOption("encoding"),compression = 6)
	if ( is.list(toWrite) ) {
		#cat("*** DEBUG START*** Now I am printing a list.\\n")
		vert <- labels( toWrite )
		write.table( print(toWrite), file=my.file, append=TRUE )
		#cat("*** DEBUG END*** Now I am printing a list.\\n")
	} else if ( is.vector(toWrite) ) {
		cat("*** DEBUG START*** Now I am printing a VECTOR.\\n")
		label <- labels( toWrite )
		if( label[1] != 1 ){
			header <- label[1]
			for( i in 2:length(label)){
				if( is.na(toWrite[i]) ){break}
				header <- paste(header, label[i], sep=",")
			}
			write( header, file=my.file, append=TRUE )
		}
		out <- toWrite[1]
		for(i in 2:length(toWrite)){
			if( is.na(toWrite[i]) ){break}
			out <- paste( out, toWrite[i], sepalpha=",")
		}
		write( out, file=my.file, append=TRUE )
		cat("*** DEBUG END*** Now I am printing a VECTOR.\\n")
	} else if ( is.matrix(toWrite) ) {
		write.table(toWrite,file=my.file,col.names=col.names,row.names=row.names,sep=",")
	} else if ( is.numeric(toWrite) ) {
		tmplabel <- labels( toWrite )
		label = tmplabel[1]
		for( i in 2:length(tmplabel)){
			label <- paste( label, tmplabel[i], sep="," )
		}
		write( label, file=my.file, append=TRUE, sep="," )
		write( toWrite, file=my.file, append=TRUE, sep="," )
	} else {
		write( toWrite, file=my.file, append=TRUE, sep="," )
	}
	close( my.file )
}
EOWRITETODISK

	my $getData = 'my.cross <- read.cross( "csv",dir="",file="URLGETDATA?probesetid='.$probeID.'&score='
		      .join(",",@covars) # this join causes the trouble
		      .'", '
		      .'genotypes=RQTLREADCROSSGENOTYPES, alleles=RQTLREADCROSSALLELES,'
		      .'na.strings=RQTLREADCROSSNASTRINGS, convertXdata=TRUE )'."\n"
		      ."my.cross <- calc.genoprob( my.cross, step=$steps, error.prob=$execParams{'errorP'} )\n";

	if( $mode eq 'scantwo' ){
		$getData .= <<EOWRITETODISK;
my.cross <- sim.geno(my.cross, step=$steps, n.draws=$execParams{'draws'})
EOWRITETODISK
	}

	my $printCov_add ="";
	if( @covars_add ){
		my $concat = "\"".join("\",\"",@covars_add)."\"";
		# The covariate 'none' should have been removed before to yield
		# an empty list of covariates.
		$printCov_add = <<EOWRITETODISK;
cov_add <- my.cross\$pheno[,c($concat)]
EOWRITETODISK
	}
	my $printCov_int ="";
	if( @covars_int ){
		my $concat_int = "\"".join("\",\"",@covars_int)."\"";
		# The covariate 'none' should have been removed before to yield
		# an empty list of covariates.
		$printCov_int = <<EOWRITETODISK;
cov_int <- my.cross\$pheno[,c($concat_int)]
EOWRITETODISK
	}

	my $writePermutations;
	my $tryPermutations = <<EOWRITETODISK;

my.$mode.S <- $mode( my.cross, $phenocol method="$execParams{'method'}"$covStr, verbose=FALSE )

# initial presumption on the eQTLs found being acceptable
acceptable <- T
my.success<-0
perms.done<-0

# if acceptable, perform check on maximal LOD found
if (acceptable) {
	if (THRESHOLD>max(my.$mode.S\$lod)) {
		cat(paste("Rejected: max(lod)=",max(my.$mode.S\$lod),"<THRESHOLD\\n",sep=""))
		acceptable <- F
	}
}

EOWRITETODISK

	my $permutationSuccessBlock;

	if ($execParams{'perms'} > 0) {

		$tryPermutations .= <<EOWRITETODISK;

# if still acceotable, perform permutation tests
if (acceptable) {
	# list of pairs identifying the number of permutations and the quantils that is to be reached
	perm.checks<-list(c(  25,                1-$execParams{'alpha'}-0.2),
			  c( 100,                1-$execParams{'alpha'}-0.02),
			  c($execParams{perms}/4,1-$execParams{'alpha'}),
			  c($execParams{perms}/2,1-$execParams{'alpha'}),
			  c($execParams{perms}  ,1-$execParams{'alpha'}))

	# iteration over partial permutations, the permutation results are stored in perm.collection
	#print(perm.checks)
	perm.collection<-NULL
	perm.no.prev.round<-0
	for(X in perm.checks) {
		print( paste(date(),": Performing ",X[1]," permutations, checking against quantile ",X[2],"\\n",sep="") )
		my.$mode.P <- $mode( my.cross, $phenocol method="$execParams{'method'}"$covStr, n.perm=X[1]-perm.no.prev.round, verbose=FALSE )
		if (is.null(perm.collection)) {
			perm.collection <- my.$mode.P
		} else {
			perm.collection <- rbind(perm.collection,my.$mode.P)
		}

		my.quants <- summary(perm.collection,alpha=(1-X[2]))
		thresh = my.quants[[1]];
		perms.done<-X[1]
EOWRITETODISK

		if( $mode eq 'scantwo' ) {
			$tryPermutations .= <<EOWRITETODISK;
		for( i in 2:5 ){ thresh = c(thresh, my.quants[[i]]) };
		if( max(my.$mode.S)\$lod.full < my.quants[['full']] ){
			print( paste(date(), ": failed assertion max(lod)>=quantile: ", max(my.$mode.S\$lod),">=", X[2], " <=> FALSE\\n",sep="") )
			acceptable <- FALSE
			break;
		}
EOWRITETODISK
		}
		else {
			$tryPermutations .= <<EOWRITETODISK;
		if( max(my.$mode.S\$lod) < thresh ) {
			print( paste(date(), ": failed assertion max(lod)>=quantile: ", max(my.$mode.S\$lod),">=", thresh, " <=> FALSE\\n",sep="") )
			acceptable <- FALSE
			break;
		}
		perm.no.prev.round<-X[1]
	}
EOWRITETODISK
		} # else of if (scantwo)

		$tryPermutations .= <<EOWRITETODISK;
	if (acceptable) {
		my.$mode.S.P.summary <- summary( my.$mode.S, perms=perm.collection, alpha=$execParams{'alpha'}, pvalues=TRUE)
		my.success <- length(my.$mode.S.P.summary[[1]])
		my.quants <- quantile(my.$mode.P, c(0,0.1,0.25,0.5,0.75,0.9,0.95,0.99,1))

		# now that the threshold is known, the eQTL of interest are determined
		my.$mode.S.summary <- summary( my.$mode.S, threshold=thresh )
	} # if acceptable after having done the permutation tests
} # if acceptable to enter permutation tests

EOWRITETODISK


		$writePermutations = <<EOWRITETODISK;

if (acceptable) {

	# write significant SNPs evaluated by permutations for their p-values
	writeToDisk( "<SUMMARY::$mode.S.P>" )
	writeToDisk( my.$mode.S.P.summary )
	writeToDisk( "</SUMMARY::$mode.S.P>" )

	# write quantiles of permutations
	writeToDisk( "<SUMMARY::quants>" )
	writeToDisk( my.quants )
	writeToDisk( "</SUMMARY::quants>" )

	# write raw data of permutations
	writeToDisk( "<DATA::$mode.P>" )
	writeToDisk( perm.collection, row.names=FALSE )
	writeToDisk( "</DATA::$mode.P>" )

}

EOWRITETODISK


	} # if ($execParams{'perms'})
	else {
		# not executed in production, but handy for debugging
		$tryPermutations .= "my.$mode.S.summary <- summary( my.$mode.S, threshold=".$execParams{'threshold'}." )\n";
	} # if-else ($execParams{'perms'})

	$writePermutations .= <<EOWRITETODISK;

if (acceptable) {
	# write plain results of $mode
	writeToDisk( "<DATA::$mode.S>" )
	writeToDisk( my.$mode.S )
	writeToDisk( "</DATA::$mode.S>" )
	writeToDisk( "<SUMMARY::$mode.S>" )
	writeToDisk( my.$mode.S.summary )
	writeToDisk( "</SUMMARY::$mode.S>" )
}
EOWRITETODISK


	if (0) {
	#FIXME: need way to write away warning and reset them
		$writePermutations .= <<EOWRITETODISK;
writeToDisk( "<WARNINGS>" )
writeToDisk( "</WARNINGS>" )
EOWRITETODISK
	}


	# status report - the first to parse

	my $c = join(",", @covars);
	my $toDisk = <<EOWRITETODISK;
writeToDisk( paste("<=$mode($probeID) success(",my.success,") method($execParams{'method'}) permutations($execParams{'perms'}) threshold($execParams{'threshold'}) covariates($c) cov_meth($execParams{'cov_meth'}) alpha($execParams{'alpha'}) steps($steps) errorP($execParams{'errorP'}) draws($execParams{'draws'}) phenocol($pc) permsDone(",perms.done,") qtlversion(",qtlversion(),") R.Version(",R.Version()[["major"]],".",R.Version()[["minor"]],") platform(",R.Version()[["platform"]],")=>", sep="") )

EOWRITETODISK

	# system status - the final line, upload checks on end with </ENV>

	my $toEnd = <<EOWRITETODISK;

writeToDisk( "<ENV>" )
writeToDisk( system("hostname -f") )
writeToDisk( Sys.info() )
writeToDisk( Sys.time() )
writeToDisk( "</ENV>" )
EOWRITETODISK


	#
	# PRINTING OF FILE STARTS HERE
	#

	print "cat( \"<eqtl mode=\\\"$mode\\\" probe=\\\"$probeID\\\" covars=\\\"".join(",",@covars)."\\\">\\n\")\n";

	print $writeToDisk;

	my $status = "print( \"\" ) \n";

	if( @covars ){
		$status .= "print( \"!-using covariates: ".join(",",@covars)."\" )\n";
	}
	$status .= "print( \"!-mode:$mode\tprobe:$probeID\" )\n";

	$status .=  <<EOWRITETODISK;
cat( paste("!-",date(),"\\n",sep="") )
cat( "\\n" )
EOWRITETODISK

	print $getData;

	if( @covars_add ){
		print $printCov_add;
	}
	if( @covars_int ){
		print $printCov_int;
	}

	print $tryPermutations;

	print $status;

	print $toDisk;

	print $writePermutations;

	print $toEnd;

	print "cat( \"</eqtl>\\n\\n\")\n";

	print "\n".'"completed"'."\n"; 

	if (!exists($ENV{'QUERY_STRING'})) {
		print STDERR "getRscript.pl: Presuming to be run from the command line: exiting.\n";
		last;
	}

}

=head1 AUTHORS

Jan Kolbaum,
Ann-Kristin Grimm,
Steffen ME<ouml>ller <moeller@inb.uni-luebeck.de>

=head1 COPYRIGHT

University of LE<uuml>beck, 2008-2009

=cut
