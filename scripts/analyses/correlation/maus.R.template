
TEMPLATEWARNINGHASH

doc<-"

=head2 FUNCTIONS

The following internal functions have been prepared for the 
correlation analysis. Some of those should be of general
interest. Some possibly even for a general interest for
R, in principle.

=over 4

=item maxc(v,num)

return the num highest values in vector v

=cut

"
maxc <- function(v, num=1) {
  if (num > length(v)) {
    warn(paste("Maxc tried to extract ",c," elements from a list of ",length(v)," elements!"))
    num<-length(v)
  }
  res <- rep(0, times=num)
  maxind <- 0
  for (i in 1:num) {
    maxind <- which.max(v)
    res[i] <- maxind
    v[maxind] = NA
  }
  return(res)
}

doc<-"

=item maxc(v,num)

return the num lowest values in vector v

=cut

"
minc <- function(v, num=1) {
  if (num > length(v)) {
    warn(paste("Minc tried to extract ",c," elements from a list of ",length(v)," elements!"))
    num<-length(v)
  }
  res <- rep(0, times=num)
  minind <- 0
  for (i in 1:num) {
    minind <- which.min(v)
    res[i] <- minind
    v[minind] = NA
  }
  return(res)
}

doc<-"

=item load.datac(type)

The function knows how to read all kinds of data and returns the
respective files. Type may be

=over 8

=item 'expression'

which reads the file 'PHENOFILE', as probes x individuals.

=item 'genotypes'

which reads the file 'GENOFILE'. The results are returned as a list with the following attributes

=over 12

=item chromosome

the chromosomes as they appear for every column with genotyping data

=item cMorgan

the cMorgan position for every marker

=item clinical

the clinical data, returned as individuals x clinical phenotype table

=item genotypes

the genotypes for all the individuals, returned as individualsxmarker table

=back

=back

=cut

"

load.data <- function(type) {
  cat("Reading ",type," data\t",sep="")
  rootdir <- paste("BASEDIR","CSVDATABASE",sep="/")
  if ("expression" == type) {
    filename <- paste(rootdir, "PHENOFILE", sep="/")
  } else if ("genotypes" == type) {
    filename <- paste(rootdir, "GENOFILE", sep="/")
  } else {
    cat(" [failed]\n",sep="")
    stop(paste("Don't know how to read data of type '",type,"'.\n",sep=""))
  }
  if (!file.exists(filename)) {
    cat(" [failed]\n",sep="")
    stop(paste("Failed to find file '",filename,"' to read ",type," data.\n",sep=""))
  }
  d<-NULL
  if ("expression" == type) {
    d.prime<-read.table(filename, header=T, sep="PHENOFIELDSEP", row.names=1, skip=PHENOLINESSKIPNO,nrows=5)
    col.numeric<-apply(d.prime,2,function(X){return(sum(!is.na(as.numeric(X)))>=4)})
    colClasses=rep("character",times=ncol(d.prime))
    colClasses[col.numeric]<-"numeric"
    if (any(!col.numeric)) {
	col.char.min<-min(which(!col.numeric))
	colClasses[col.char.min:ncol(d.prime)]<-"character"
    }
    colClasses<-c("character",colClasses)
    d<-read.table(filename, header=T, sep=",", row.names=1, skip=1, stringsAsFactors=F,colClasses=colClasses)
    if (any(!col.numeric)) {
        d<-d[,1:col.char.min]
    }
    # This needs to be helped, somehow
    d<-d[,1:150]
    cat(paste(" [ok]  dimension is [",paste(dim(d),collapse=",",sep=""),"]\n",sep=""),sep="")
    return(d)
  } else if ("genotypes" == type) {
    d <- read.table(filename, header=T, sep=",", skip=0, stringsAsFactors=F)
    d.chr<-d[1,]
    d.chr.first<-min(which(!is.na(as.numeric(d.chr))))
    d.chr<-as.character(d[1,d.chr.first:ncol(d)])
    d.morgan<-as.numeric(d[2,d.chr.first:ncol(d)])
    d.clinical<-d[3:nrow(d),1:(d.chr.first-1)]
    d.genotypes<-d[3:nrow(d),d.chr.first:ncol(d)]
    cat(paste(" [ok]  Read ",ncol(d.clinical)," classical phenotypes ",
              "and ", ncol(d.genotypes)," genotypes for ",
	      nrow(d.genotypes), " individuals.\n",sep=""),sep="")
    l<-list()
    l[["chromosomes"]]<-d.chr
    l[["cMorgan"]]<-d.morgan
    l[["clinical"]]<-d.clinical
    l[["genotypes"]]<-d.genotypes
    return(l)
  } else {
    stop(paste("Don't know how to read data of type '",type,"'.\n",sep=""))
  }

}



##### Extracting values
# Initialisation of chromosomes, cMorgan distances and the expression values
expr <- load.data("expression") # probes x individuals
exprrownames <- rownames(expr)

quandata <- load.data("genotypes")
# Look for marker data on chromosomes
chromos <- quandata$chromosomes
chromnames <- unique(chromos)
# Look for cMorgan distances on markers
cmorgan <- quandata$cMorgan
# get genotypes in same orientation
marker <- t(quandata$genotypes)
# Extract marker names
markerrownames <- rownames(marker)
# and analogously for clinical phenotypes
clinical <- t(quandata$clinical)

# Remove the first two lines (chromos and cmorgan)
#quan <- apply(quandata[,3:dim(quandata)[2]], c(1, 2), as.numeric)
#cat("Loaded quantitative data\n")
#cat(dim(quan)); cat("\n")


##### Plot some expression samples
plotExpr <- function(expr, ch=c(1,2),...) {
  xlab=paste("Probeset",rownames(expr)[ch[1]],sep=": ")
  ylab=paste("Probeset",rownames(expr)[ch[2]],sep=": ")
  plot(t(expr[ch[1],]), t(expr[ch[2],]), xlab=xlab, ylab=ylab)
}


if (F) {
# a routine of some value for interim evaluation while developing
# Randomly take n samples of expression pairs and plot them one after another
plotExprSamples <- function(expr, n = 20) {
  p<-par("ask")
  par("ask"=T)
  for (i in 1:n) {
    ch <- sample(1:dim(expr)[1], 2, replace=F)
    cat(ch); cat("\n")
    plotExpr(expr, ch)
  }
  par("ask"=p)
}

if (F) {
# a routine of some value for interim evaluation while developing
# Randomly take n samples of expression pairs (with p elements) and plot them one after another
plotExprPairs <- function(expr, n = 20, p = 3) {
  a<-par("ask")
  par("ask"=T)
  cat("Selecting ",p," probes to compare all against all.\n")
  for (i in 1:n) {
    ch <- sample(1:dim(expr)[1], p, replace=F)
    cat(ch); cat("\n")
    pairs(t(expr[ch,]))
  }
  par("ask"=a)
}
}


##### Extract the EAE values and corresponding cols
getEAE <- function(quan) {
  eaev <- as.numeric(quan['eae',])
  notna <- which(!is.na(eaev))
  val <- eaev[notna]
  val[val == 0] <- -1
  return(list(val, notna))
}
eae <- getEAE(quan)


##### Analyze clusters on pairs of expressions by marker values
# e1 and e2 are indices of expression data rows, m is the marker index
# draw is a boolean and activates the graphical output
analyzeclusters <- function(e1, e2, m, draw = F) {
  # get expression data (and make them columns)
  ed <- t(expr[c(e1, e2), ])
  # get marker data
  md <- marker[m,];
  pindices <- which(md == 1)
  nindices <- which(md == 2)
  naindices <- which(is.na(md))
  if (length(pindices) == 0 || length(nindices) == 0)
    return(0)
  # set color vector
  col <- rep("gray", length(md))
  col[pindices] <- "green"
  col[nindices] <- "red"
  # evaluate the markerwise (classwise) means
  posm <- colMeans(ed[pindices,])
  negm <- colMeans(ed[nindices,])
  # if drawing is activated
  if (draw) {
    xlab <- paste("Probeset", exprrownames[e1], sep=" ")
    ylab <- paste("Probeset", exprrownames[e2], sep=" ")
    sub <- paste("Marker ", markerrownames[m], sep="")
    pch <- rep(21, length(col))
    pch[naindices] <- 20
    plot(ed[,1], ed[,2], col=col, pch=pch, xlab=xlab, ylab=ylab, sub=sub)
    points(t(posm), col = "green", pch = 8, cex = 2)
    points(t(negm), col = "red", pch = 8, cex = 2)
  }
  res <- list(posm = posm, negm = negm)
  return(res)
}

# Evaluate the differences of the means for each markerpair
evalresiduals <- function(e1, e2) {
  sa<-sapply(markerrownames,function(m) {
      res <- analyzeclusters(e1, e2, m, F)
      return(c(posm=res$posm[1],
      	       posm=res$posm[2],
               negm=res$negm[1],
	       negm=res$negm[2]))
  })
  geom.diff <- sqrt(colSums(sa[1:2,] - sa[3:4,])^2))
  return(geom.diff)
}

# 
find.best.markers <- function(e1, e2,n=1) {
	evalresiduals(e1,e2)

}



e1 <- 1444
e2 <- 3821
m <- 134
analyzeclusters(e1, e2, m, T)


e1 <- 1444
e2 <- 7199
m <- 99
analyzeclusters(e1, e2, m, T)



##### Analyze the difference of means for markers for different expression pairs
# the results are complex, thus the will be saved to file such that intermediate
# results can be recovered after crash
e1 <- 1444
fname <- paste(c("test", e1, "csv"), collapse=".")
for (e2 in (e1+1):dim(expr)[1]) {
  r <- evalresiduals(e1, e2)
  m <- maxc(r)
  analyzeclusters(e1, e2, 134, F)
  # This value function is for comparing, higher values are better
  v <- max(r) / sqrt(var(r))
  data <- paste(c(paste(c(e1, e2, m, v), collapse=", "), "\n"), collapse="")
  # Save to file
  cat(data, file=fname, append=T)
}



##### Analyse one interesting pair (1444, 3821)
# Do a k-means analysis on given pair
cp <- c(1444, 3821)
kmeansres <- kmeans(t(expr[cp,]), 2)
# Draw the results
plot(t(expr[cp,]), col=kmeansres$cluster)
points(kmeansres$centers, col=1:2, pch=8, cex=2)

# Evaluate k-means clusters (this was just for testing and can be deleted in my opinion)
c1 <- which(kmeansres$cluster==1)
c2 <- which(kmeansres$cluster==2)
ce <- kmeansres$centers
d <- ce[2,] - ce[1,]
dis <- sqrt(d[1]^2 + d[2]^2)
p1 <- sqrt(var(colSums(d * expr[cp, c1])))
p2 <- sqrt(var(colSums(d * expr[cp, c2])))
evalPair <- function(expr, pair, show) {
  kmeansres <- kmeans(t(expr[pair,]), 2)
   if (show) {
    plot(t(expr[pair,]), col=kmeansres$cluster)
    points(kmeansres$centers, col=1:2, pch=8, cex=2)
  }
  c1 <- which(kmeansres$cluster==1)
  c2 <- which(kmeansres$cluster==2)
  ce <- kmeansres$centers
  d <- ce[2,] - ce[1,]
  dis <- sqrt(d[1]^2 + d[2]^2)
  p1 <- sqrt(var(colSums(d * expr[pair, c1])))
  p2 <- sqrt(var(colSums(d * expr[pair, c2])))
  return((p1 + p2) / dis)
}

# Find a high correleation of clusters to other expression values (10 examples)
maxi <- maxc(abs(cor(kmeansres$cluster, t(expr[-cp,]))), 10)
plot(t(expr[c(cp[1], cp[2]),]), col=kmeansres$cluster)
p<-par(ask)
par(ask=T)
for (i in 1:10) {
  plot(t(expr[c(cp[2],maxi[i]),]), col=kmeansres$cluster)
}
par(ask=p)

# Decision tree for clusters of cp on markers
library(rpart)
dtdata <- as.data.frame(kmeansres$cluster)
colnames(dtdata)[1] <- "cluster"
dtdata <- cbind(dtdata, t(marker))
dtdataframe <- data.frame(dtdata)
mnames <- rownames(marker)
# Create formula
f <- paste(c("cluster~", paste(mnames, collapse="+")), collapse="")
dtc <- rpart.control(xval=1, minbucket=2, minsplit=4, cp=0.02)
# Build tree
r <- rpart(formula = f, data = dtdataframe, method="class", control=dtc)
# Draw tree
plot(r, branch=.3, compress=T)
text(r)



##### 3D-Scatterplot example
scatterexample <- function() {
  c1 = rep(5:10, times=6)
  c2 = rep(5:10, each=6)
  c3 = 3 - 5*c1 - 5*c2 + c1 * c2 + rnorm(6*6)
  c <- data.frame(c1 = c1, c2 = c2, c3 = c3)
  s3d <- scatterplot3d(c, type="h", highlight.3d=TRUE, 
         angle=75, scale.y=0.7, pch=16, main="scatterplot3d - 5")
  my.lm <- lm(c3 ~ c1 + c2 + c1:c2)$coefficients
  c3p <- my.lm[1]+my.lm[2]*c1+my.lm[3]*c2+my.lm[4]*c1*c2
  s3d$points3d(data.frame(c1, c2, c3p))
}



##### Search for expression values corresponding to EAE
c <- cor(eae[[1]], t(expr[,eae[[2]]]))
numcand <- 15
cand <- minc(abs(c), numcand)
# Search for linear model for AEA
lmdata <- data.frame(t(rbind(eae = eae[[1]] , expr[cand, eae[[2]]])))
cn <- colnames(lmdata)
res <- c()
for (fac1 in 2:(length(cn)-1)) {
  for (fac2 in (fac1+1):length(cn)) {
    f <- as.formula(paste("eae ~ ", cn[fac1], "+", cn[fac2], "+", cn[fac1], ":", cn[fac2], collapse=""))
    mylm <- lm(f, data = lmdata)
    res <- rbind(res, c(fac1, fac2, mean(abs(mylm$residuals))))
  }
}
print(res)

x <- rnorm(15)
y <- 10*x + rnorm(15)
predict(lm(y ~ x))
# this is not finished yet, one could further used the linear model for a predictor
# and evaluate the quality of such a classification.



##### Build decision tree directly from markers
library(rpart)
dtdata <- matrix(eae[[1]])
colnames(dtdata)[1] <- "eae"
dtdata <- cbind(dtdata, t(marker[, eae[[2]]]))
dtdataframe <- data.frame(dtdata)
mnames <- rownames(marker)
# Create formula
f <- paste(c("eae~", paste(mnames, collapse="+")), collapse="")
dtc <- rpart.control(xval=1, minbucket=2, minsplit=4, cp=0.02)
# Build tree
r <- rpart(formula = f, data = dtdataframe, method="class", control=dtc)
# Draw tree
plot(r, branch=.3, compress=T)
text(r)





##### This stuff is old and not used anymore
#correl <- cor(eae, t(expr[,ms]))

testexpr <- abs(cor(t(expr[1:100,])))
testexpr[testexpr == 1] <- 0
which(testexpr > 0.992, arr.ind=T)


# Calculate entropy of probabilities p
entropy <- function(p) {
  p.sum <- sum(p)
  if (min(p) < 0 || p.sum <= 0)
    return(NA)
  p.norm <- p[p > 0] / p.sum
  return(-sum(log2(p.norm) * p.norm))
}


#entropy(c(sum(eae>0),sum(eae<0)))

# eae = sign(f1 * gen1 + f2 * gen2 + f3 * gen1 * gen2)


