#!/usr/bin/env r

doc<-"

=head1 NAME

effectPlot.R - show quantitative influence of genotype of expression level

=head1 SYNOPSIS

effectPlot.R [options]

or to be sourced from within an R shell

=head1 DESCRIPTION

=head1 OPTIONS

=over 4

=item verbose

=item help

=item trait I<trait_id>

Only a single trait is worked on. If there is demand, this will be extended towards the simultaneous treatment of multiple traits.

=item LODmin minimalLODscore

only loci with a LOD score of at least the value denoted will be included in the analysis (not yet implemented)

=item cisDistMax maximalDistanceFromPeak

only show effect for cis-acting loci (not yet implemented)

=item interactive

rather than dumping an image to a file, specified by '--output', the result can be analysed interactively with the R shell . This is useful only when sourcing the script from within an R shell

=item format <png|jpeg|pdf>

The graphics format to be used. The default is 'png'. To use the typical display of the R shell, use set --interaction.

=item covariates

list of covariates to be included  (not implemented)

=item output

complete path to file to include the resulting image, without any .jpeg etc suffix, please. Multiple images may be created (with highly-scored QTL on multiple chromosomes). It will receive a filename with _Chr_cM suffix.

=item width I<number>

The width of the figure, either in pixels (png, jpeg) or inch (pdf).

=item height I<number>

The width of the figure, defaults to width unless explicitly set.

=back


=head1 AUTHORS

Steffen ME<ouml>ller <moeller@inb.uni-luebeck.de>,

=head1 COPYRIGHT

University of LE<uuml>beck, Germany, 2009

=cut

"

##
##  I N T E R N A L   F U N C T I O N S
##

#
# prepare the output file
#
prepareOutput<-function(filename) {
	if (is.null(filename)) {
		stop("prepareOutput has NULL as filename\n")
	}
	if (is.null(opt$interactive)) {
		if (is.null(opt$format) || "png" == opt$format) {
			png(filename,width=width.pixel,height=height.pixel)
		}
		else if ("pdf" == opt$format) {
			pdf(filename,width=width.inch,height=height.inch)
		}
		else if ("jpg" == opt$format  || "jpeg" == opt$format) {
			jpg(filename,width=width.pixel,height=height.pixel)
		}
		else if ("gif" == opt$format) {
			jpg(filename,width=width.pixel,height=height.pixel)
		}
		else {
			cat("Unknown format ",opt$format,"\n")
			q(status=1);
		}
	}
}

library(getopt)
library(qtl)


# cat("I was here 0.\n")

width.pixel<-2*480
width.inch<-11
height.pixel<-width.pixel
height.inch<-width.inch

opt = getopt(matrix(c(
    'verbose'    , 'v', 2, "integer",
    'debug'      , 'd', 2, "integer",
    'help'       , 'h', 0, "logical",
    'trait'      , 't', 1, "character",
    'chromosome1', 'e', 2, "character",
    'chromosome2', 'w', 2, "character",
    'cM1'        , 'm', 2, "double",
    'cM2'        , 'n', 2, "double",
    'marker1'    , 'a', 2, "double",
    'marker2'    , 'b', 2, "double",
    'LODmin'     , 'l', 1, "double",
    'interactive', 'i', 0, "logical",
    'format'     , 'f', 1, "character",
    'covariates' , 'c', 1, "character",
    'output'     , 'o', 1, "character"
   ),ncol=4,byrow=TRUE), debug=TRUE)

if (!is.null(opt$help)) {
   cat("Please run 'pod2man createVenn.R | nroff -man | less' on this script to gain more insights.\n")
   q(status=1);
}

if (is.null(opt$trait)) {
   cat("Please place trait  with -t option.\n")
   q(status=1);
}

if (is.null(opt[["marker1"]])) {
	if (is.null(opt$chromosome1) & is.null(opt$cM1)) {
	   cat("Neither marker nor chr/cM pair specified.\n")
	   q(status=1);
	}
}

if (is.null(opt$LODmin)) {
	opt[["LODmin"]] <- 3.5
	if (!is.null(opt$verbose)) cat("Setting default LODmin to ",opt$LODmin,"\n");
}

#if (is.null(opt$cisDistMax)) {
#	opt[["cisDistMax"]] <- 20*1000*1000
#	if (!is.null(opt$verbose)) cat("Setting default cisDistMax to ",opt$cisDistMax,"\n");
#}

if (is.null(opt$format)) {
   opt[["format"]]<-"png";
   cat("Set format to default value '",opt$format,"'.\n",sep="")
}

if ("pdf" == opt$format) {
	if (!is.null(opt$width)) {
		width.inch<-opt$width
	}
	if (!is.null(opt$height)) {
		height.inches<-opt$height
	}
	else {
		height.inch<-width.inch
	}
} else {
	if (!is.null(opt$width)) {
		width.pixel<-opt$width
	}
	if (!is.null(opt$height)) {
		height.pixel<-opt$height
	}
	else {
		height.pixel<-width.pixel
	}
}

#
# Read data - just the default one as a start
#

fname.input<-paste(
	"http://grid64inb.inb.uni-luebeck.de:80/~moeller/stockholm/prepareRqtlInputData.pl?probesetid=",
	opt$trait,
	"&applyLog2=TRUE&score=",sep="")

my.cross <- NULL
my.cross <- read.cross(	format="csv", dir="",
                       	file=fname.input,
		        genotypes=RQTLREADCROSSGENOTYPES,
			alleles=RQTLREADCROSSALLELES ,
			na.strings=RQTLREADCROSSNASTRINGS, convertXdata=TRUE )

if (is.null(my.cross)) {
	cat("Could no read data for trait '",trait,"'.\n")
	q("no")
}

ep<-function(marker,chr,cM) {
	cat("ep:start\n")
	mname1<-NULL
	#if (is.null(marker))
	if (T) {
		# Find marker closest to the Chr and cMorgan specified
		cat("ep:find.marker")
		mname1 <- find.marker(my.cross, chr, cM)
		#mname1 <- find.marker(my.cross, 1, 30)
		cat("Investigating marker '",mname1,
			" as determined from coordinates ",chr,"@",cM,".\n")
	}
	else {
		# Use marker as specified
		mname1 <- marker
		cat("Investigating marker '",mname1," as specified\n")
	}

	if (is.null(mname1)) {
		cat("ep: Could not determine marker.\n")
	}

	#	Effect Plots

	f<-paste(opt$output,"_",mname1,"exact_trait",".",opt$format,sep="")
	cat(paste("<a href=\"",f,"\">",f,"</a>\n",sep=""))
	prepareOutput(f)
	cat("ep:invocation of effectplot\n")
	effectplot(my.cross,mname1=mname1)
	if(is.null(opt$interactive)) {
		dev.off()
	}
	cat("ep:end\n")
}

m<-opt[["marker1"]]
chr<-opt[["chromosome1"]]
cM<-opt[["cM1"]]

if (is.null(m) & (is.null(cM) | is.null(chr))) {
	stop("The rerun of single QTL analysis is not yet implemented.\n")
	# no locus specified, go for them all
	my.cross <- calc.genoprob( my.cross, step=1, error.prob=0.01 )
	my.scanone.S <- scanone( my.cross, pheno.col=3, method="hk", verbose=FALSE )
} else {
	if (is.null(cM)|is.null(chr)) {
		stop("Please specify both cM ('",cM,"') and chr ('",chr,"').\n",sep="")
	}
	ep(m,chr,cM)
}
