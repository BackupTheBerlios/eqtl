#!/usr/bin/env r

doc<-"

=head1 NAME

scatter_all.R - prepare scatter plots for all covariates

=head1 SYNOPSIS

scatter_all.R [options]

=head1 DESCRIPTION

This script plots the chromosomal location of the QTL 
against the chromosomal location of the gene it affects.

The data is futher described by the presentation of classical QTL
as dark bars.

=over 4

=item verbose <level>

adds status reports - possibly insightful to interpret problems from users. A distinction between levels is not made.

=item help

instructions to use pod2man for seeing this documentation.

=item MeanMin <value>

Minimal expression level for a trait to be shown.

=item LODmin

Minimal LOD score for a QTL to be shown.

=item Pmax

Maximal P-value for a QTL to be shown

=item interactive

to be set if the user shall be interactively working with the R shell rather than preparing an image file or a PDF.

=item format

the format in which the image is to be saved - pdf, jpeg, png are currently supported.

=item covariates

the covariates that should be compared

=item output

the output file to which to write - if there is a file to write to.

=item --qtls I<comma-separated list of QTLs>

expects list of QTLs (their IDs in the database) that shall be represented on the plot -- still needs to be implemented

=item --linecolour I<string>

name of colour of lines to separate the chromosomes

=item --linewidth I<number>

width of lines separating the chromosomes

=item --linetype 0-5

specification of the type of lines tha shall be separating the chromosomes, defaults to 3 (dotted)

=item --axescolour I<string>

colour of axes

=item --axeswidth I<number>

width of axes

=item --axestype I<number>

type of axes

=item --imagewidth I<number>

width of image, the units depend on the format of the image, png needs the number of pixels, pdf needs inches.

=back

=head1 AUTHORS

Steffen Moeller <moeller@inb.uni-luebeck.de>,
ME<eacute>lanie ThessE<eacute>n Hedreul,
Maja Jagodic E<#263>

=head1 COPYRIGHT

University of LE<uuml>beck, Germany, and Karolinska Institute, Stockholm, Sweden

=cut

"

width.pixel<-3*480
width.inch<-11
height.pixel<-width.pixel
height.inch<-width.inch
bp.offset.extra<-0.15*10^8
cM.offset.extra<-8

# indication of percentage separation betweeen
# chromosomes
offset.percent<-2

library(RMySQL)
library(getopt)

# cat("I was here 0.\n")

opt = getopt(matrix(c(                                            
   'verbose'    , 'v', 2, "integer",  "gives information on the internal status of program",
   'help'       , 'h', 0, "logical",  "gives instructions on how to retrieve information on how to use the program",
   'MeanMin'    , 'm', 1, "double",   "the threshold for a minimal expression level that the trait should have to be selected for display (as a dot on the plot)",
   'LODmin'     , 'l', 1, "double",   "the minimal LOD score the expression QTL should have reached",
   'LODmax'     , 'L', 1, "double",   "the maximal LOD score the expression QTL allowed in (defaults to THRESHOLD)",
   'Pmax'       , 'p', 1, "double",   "the maximal P value the expression QTL may have reached to be considered significant",
   'Pmin'       , 'P', 1, "double",   "the minimal P value the expression QTL may have reached to leave out the most significant eQTL",
   'interactive', 'i', 0, "logical",  "indication that this script is run from the UNIX shell",
   'format'     , 'f', 1, "character","the format of the image that should present the plot",
   'covariates' , 'c', 1, "character","covariates the plot shall be run for",
   'output'     , 'o', 1, "character","name of output file",
   'qtls'       , 'q', 2, "character","list of QTLs (their IDs in the database) that shall be represented on the plot",
   'display'    , 'd', 2, "character","defaults to lod, alternatives are rank and p.value",
   'main'       , 'M', 1, "character","main title of the plot",
   'sub'        , 'S', 1, "character","sub title of the plot",
   'imagewidth' , 'W', 1, "integer",  "width of image, represented in dependency on the format",
   'imageheight', 'H', 1, "integer",  "height of image, represented in dependency on the format",
   'linecolour' , 'a', 1, "character","colour of lines separating the chromosomes",
   'linewidth'  , 'w', 1, "double",   "width of lines separating the chromosomes",
   'linetype'   , 't', 1, "integer",  "type of lines separating the chromosomes",
   'axescolour' , 'b', 1, "character","colour of axes",
   'axeswidth'  , 'x', 1, "double",   "width of axes",
   'axestype'   , 'y', 1, "integer",  "line type of axes",
   'legend'     , 'e', 2, "logical",  "set to add a legend"
   ),ncol=5,byrow=TRUE),
   debug=TRUE)

if (!is.null(opt$verbose)) cat("I was here 1.\n")

if ( !is.null(opt$help) ) {
   cat("Please run 'pod2man scatter_all.R | nroff -man | less' on this script to gain more insights.\n");
   cat(paste("Output can be expected at file '",opt$output,"'.\n",sep=""))
   q(status=1);
}

if (is.null(opt$output)) {
   if (!is.null(opt$verbose)) cat("Set ouput to default value.\n")
   opt[["output"]]<-"/tmp/default_output_scatter_all.pdf"
}
if (is.null(opt$MeanMin)) {
   if (!is.null(opt$verbose)) cat("Set MeanMin to default value.\n")
   opt[["MeanMin"]]<- -1
}
if (is.null(opt$LODmin)) {
   if (!is.null(opt$verbose)) cat("Set LODmin to default value: THRESHOLD (minimal requested for db storage)\n")
   opt[["LODmin"]]<- THRESHOLD 
}
if (is.null(opt$Pmax)) {
   if (!is.null(opt$verbose)) cat("Set Pmax to default value: 1.\n")
   opt[["Pmax"]]<- 1
}
if (is.null(opt$Pmin)) {
   if (!is.null(opt$verbose)) cat("Set Pmin to default value.\n")
   opt[["Pmin"]]<- 0
}
if (is.null(opt$format)) {
   opt[["format"]]<-"png";
   if (!is.null(opt$verbose)) cat("Set format to default value '",opt$format,"'.\n")
}
if (is.null(opt$display)) {
   opt[["display"]]<-"lod";
   if (!is.null(opt$verbose)) cat("Set variable to display to '",opt$display,"'.\n")
}

if (is.null(opt$linecolour)) {
   opt[["linecolour"]]<-"lightgray"
   if (!is.null(opt$verbose)) cat("Set colour for lines : ",opt$linecolour,"\n")
}

if (is.null(opt$linewidth)) {
   opt[["linewidth"]]<-1
   if (!is.null(opt$verbose)) cat("Set width for lines : ",opt$linewidth,"\n")
}

if (is.null(opt$linetype)) {
   opt[["linetype"]]<-3
   if (!is.null(opt$verbose)) cat("Set type for lines : ",opt$linetype,"\n")
}

if (is.null(opt$axeswidth)) {
   opt[["axeswidth"]]<-3
   if (!is.null(opt$verbose)) cat("Set width for axes : ",opt$axeswidth,"\n")
}

if (is.null(opt$axescolour)) {
   opt[["axescolour"]]<-3
   if (!is.null(opt$verbose)) cat("Set colour for axes : ",opt$axescolour,"\n")
}

if (is.null(opt$imagewidth)) {
   if (is.null(opt$format) || opt$format %in% c("png","jpeg","jpg","gif")) {
	opt[["imagewidth"]]<-width.pixel
   }
   else if ("pdf" == opt$format) {
	opt[["imagewidth"]]<-width.inch
   }
   else {
	cat("Unknown format ",opt$format,"\n")
	q(status=1);
   }
}

if (is.null(opt$imageheight)) {
   if (is.null(opt$format) || opt$format %in% c("png","jpeg","jpg","gif")) {
	opt[["imageheight"]]<-height.pixel
   }
   else if ("pdf" == opt$format) {
	opt[["imageheight"]]<-height.inch
   }
   else {
	cat("Unknown format ",opt$format,"\n")
	q(status=1);
   }
}

#if (!is.null(opt$verbose)) cat("I was here 2.\n")

con <- dbConnect(MySQL(),host="DATABASEHOSTLOCAL",db="DATABASEEQTLNAME",user="DATABASEEQTLUSER")

#if (!is.null(opt$verbose)) cat("I was here 3.\n")

# find maximal cM for every chromosome

q <- "SELECT locus.chr, MAX(cMorgan_Peak) as max FROM qtl JOIN locus on qtl.Locus=locus.Name GROUP BY locus.chr;"
chromosomal.length.cM<-dbGetQuery(con,q)
rownames(chromosomal.length.cM)<-chromosomal.length.cM[,1]
cM.offset<-c(0,cumsum(chromosomal.length.cM[c(1:(POSITIONOFXCHROMOSOME-1),"X"),"max"]+cM.offset.extra))
names(cM.offset)<-c(1:(POSITIONOFXCHROMOSOME-1),"X" #,"Y"
)

#if (!is.null(opt$verbose)) cat("I was here 4.\n")

# find maximal bp for every chromosome

q <- "SELECT chromosome, MAX((start+stop)/2) as max FROM trait GROUP BY chromosome;"
chromosomal.length.bp<-dbGetQuery(con,q)
rownames(chromosomal.length.bp)<-chromosomal.length.bp[,1]
bp.offset<-c(0,cumsum(chromosomal.length.bp[c(1:(POSITIONOFXCHROMOSOME-1),"X"),"max"]+bp.offset.extra))
names(bp.offset)<-c(1:(POSITIONOFXCHROMOSOME-1),"X" #,"Y"
)

#if (!is.null(opt$verbose)) cat("I was here 5.\n")

# Find covariates to work on

q <- "select distinct covariates from qtl;"
covariates.queried<-c("none",dbGetQuery(con,q)[,"covariates"])
cat(paste("Found the following covariates in the database: '",
          paste(covariates.queried,collapse="';'",sep=""),"'\n",sep=""))

#if (!is.null(opt$verbose)) cat("I was here 6.\n")

covariates.filter.string<-opt$covariates
if(is.null(covariates.filter.string)) {
	cat("W: Falling back to default values for covariates.\n")
	covariates.filter.string<-"max_add;bd_int;dud_int;dud_add;max_add,dud_add;eae_add;eae_add,dud_add;sud_add"
}
covariates.filter.list<-strsplit(covariates.filter.string,";")[[1]]

#if (!is.null(opt$verbose)) cat("I was here 7.\n")


covariates<-covariates.queried[covariates.queried %in% covariates.filter.list]

cat(paste("Working with the following covariates: ",paste(covariates,collapse=";",sep=""),".\n",sep=""))



# do it for all covariates


if (is.null(opt$interactive)) {
	if (file.exists(opt$output)) {
		cat(paste("Removing file '",opt$output,"'\n",sep=""))
		file.remove(opt$output);
		if (file.exists(opt$output)) {
			cat("Could not remove file",opt$output,".\n")
			q(status=1)
		}
	}
	if (is.null(opt$format) || "png" == opt$format) {
		png(opt[["output"]],width=opt$imagewidth,height=opt$imageheight)
	}
	else if ("pdf" == opt$format) {
		pdf(opt[["output"]],width=opt$imagewidth,height=opt$imageheight)
	}
	else if ("jpg" == opt$format  || "jpeg" == opt$format) {
		jpg(opt[["output"]],width=opt$imagewidth,height=opt$imageheight)
	}
	else if ("gif" == opt$format) {
		jpg(opt[["output"]],width=opt$imagewidth,height=opt$imageheight)
	}
	else {
		cat("Unknown format ",opt$format,"\n")
		q(status=1)
	}
}

for(cov in covariates) {

  cat(paste("Working on covariate '",cov,"', used internally as '",if("none" != cov) cov else "","'\n",sep=""))

  # Input for plot

  q <- paste("SELECT ",
	      "Trait,LOD,pvalue,",				# 1 2 3
	      "locus.chr,cMorgan_Peak,",			# 4 5
	      "covariates,",					# 6
	      "trait.chromosome,(trait.start+trait.stop)/2 ", 	# 7 8
	      "as pos ",
           "FROM ",
              "qtl JOIN trait ON trait_id=Trait JOIN locus ON locus.Name=qtl.Locus ",
           "WHERE ",
              "covariates='",if("none" != cov) cov else "","'",sep="")
  if (!is.null(opt$LODmin) && -1 < opt$LODmin) {
	q <- paste(q," AND LOD >= ",opt$LODmin,sep="")
  }
  if (!is.null(opt$Pmax) && -1 < opt$Pmax && 1>opt$Pmax) {
	 q <- paste(q," AND pvalue <= ",opt$Pmax,sep="")
  }
  if (!is.null(opt$MeanMin) && -1 < opt$MeanMin) {
	 q <- paste(q," AND mean >= ",opt$MeanMin,sep="")
  }
  q <- paste(q,";",sep="")

#Trait, Locus, LOD, covariates, Chromosome, cMorgan_Peak, cMorgan_Min, cMorgan_Max, Quantile, (LOD-Quantile) as LODdiff , unigene, swissprot_ID, gene_assignment, first_symbol,
#       first_name, ProbeSequence, seqname as chr_name, strand, start as gene_chrom_start,stop as gene_chrom_end,
#       trait.mean, trait.sd 
#
# SELECT Trait, Locus, LOD, covariates, Chromosome, cMorgan_Peak, cMorgan_Min, cMorgan_Max, Quantile, (LOD-Quantile) as LODdiff , unigene, swissprot_ID, gene_assignment, first_symbol,
#       first_name, ProbeSequence, seqname as chr_name, strand, start as gene_chrom_start,stop as gene_chrom_end,
#       trait.mean, trait.sd 
# FROM qtl left join BEARatChip as c on Trait=c.probeset_id join trait on qtl.Trait=trait.trait_id WHERE Chromosome in ('2') AND mean >= 100 AND covariates='bd_int' AND LOD >= 4 ORDER BY LOD DESC
#
#


  if (!is.null(opt$verbose)) {
      cat("Query: ",q,"\n")
  }

  selected.qtl<-dbGetQuery(con,q)

  pos.linear.cM<-apply(selected.qtl,
      1,
      function(X){
	 linearCentiMorgan<-cM.offset[X[4]]
	 offset<-as.numeric(X[5])
         return(linearCentiMorgan+offset)
      }
  )

  pos.linear.bp<-apply(selected.qtl,
      1,
      function(X){
	 linearBP<-bp.offset[X[7]]
	 offset<-as.numeric(X[8])
         return(linearBP+offset)
      }
  )

  if (is.null(opt$main)) {
  	opt[["main"]]<-cov
	if (!is.null(opt$verbose)) cat("Set main title to ",opt$main,"\n")
  }

  if (is.null(opt$sub)) {
  	opt[["sub"]]<-paste("Showing ",opt$display," of eQTL with LOD>=",opt$LODmin," and P-value<=",opt$Pmax," and mean expression>=",opt$MeanMin)
	if (!is.null(opt$verbose)) cat("Set sub title to ",opt$sub,"\n")
  }

  if (!is.null(opt$legend)) {
     if (!is.null(opt$verbose)) cat("Prepared split for legend.\n")
     nf <- layout(matrix(c(1,2), 1, 2, byrow=TRUE), width=c(6,lcm(4)),heights=c(1),respect=FALSE)
     #nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)
     #layout.show(nf)
  }

  plot(bp.offset.extra + pos.linear.cM,
       cM.offset.extra + pos.linear.bp,
     xlim=c(0,max(cM.offset)),ylim=c(0,max(bp.offset)),
     axes=FALSE,main=opt$main,sub=opt$sub)
  abline(v=cM.offset, col=opt$linecolour, lty=opt$linetype, lwd=opt$linewidth,add=TRUE)
  abline(h=bp.offset, col=opt$linecolour, lty=opt$linetype, lwd=opt$linewidth,add=TRUE)

  if (!is.null(opt$verbose)) {
    cat("Colnames(selected.qtl) : " , paste(colnames(selected.qtl),collapse=",",sep=""),"\n")
    cat("Dim(selected.qtl) : "); print(dim(selected.qtl))
  }

  # keeping values visible for legend
  selected.qtl.values<-NULL
  selected.qtl.max<-NULL
  selected.qtl.min<-NULL

  YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
  color.palette = colorRampPalette(YlOrBr, space = "Lab",bias = 0.5)
  #FIXME: the ranking should be separated from the value selected
  if ("rank"==opt$display) {
          if (!is.null(opt$verbose)) cat("displaying rank-based data.\n")
	  #selected.qtl.values<-selected.qtl[,"pvalue"]
	  selected.qtl.values<-selected.qtl[,"LOD"]
	  selected.qtl.max=max(selected.qtl.values)
	  selected.qtl.min=min(selected.qtl.values)
	  selected.qtl.quantiles=sapply(selected.qtl.values,function(X){sum(X>selected.qtl.values)})
	  plot(1:10)
	  points(pos.linear.cM,  pos.linear.bp,  col=color.palette(length(selected.qtl.quantiles))[selected.qtl.quantiles])
	 
  } else if (opt$display %in% c("p.value","P value","P-value","p value","p-value","pvalue","Pvalue")) {
          if (!is.null(opt$verbose)) cat("displaying pvalue data.\n")
	  selected.qtl.values<-selected.qtl[,"pvalue"]
	  selected.qtl.max=max(selected.qtl.values)
	  selected.qtl.min=min(selected.qtl.values)
	  points(pos.linear.cM,  pos.linear.bp,  col=color.palette(length(selected.qtl.values))[
			# 0 is best, thus substracting from max
			round((selected.qtl.max-selected.qtl.values)/(selected.qtl.max-selected.qtl.min)*length(selected.qtl.values),0)
		])
  } else if (opt$display %in% c("LOD","lod")) {
          if (!is.null(opt$verbose)) cat("displaying LOD data.\n")
	  selected.qtl.values<-selected.qtl[,"LOD"]
	  selected.qtl.max=max(selected.qtl.values)
	  selected.qtl.min=min(selected.qtl.values)
	  points(pos.linear.cM,  pos.linear.bp,  col=color.palette(length(selected.qtl.values))[
			# the higher the better
			round((selected.qtl.values-selected.qtl.min)/(selected.qtl.max-selected.qtl.min)*length(selected.qtl.values),0)
		])
  } else {
	stop(paste("Unknown display attribute value: '",opt$display,"'.",sep=""))
  }
  
 
  #in.green<-selected.qtl[,"LOD"]>=8
  #points(pos.linear.cM[in.green],pos.linear.bp[in.green],col="green")

  axis(1, at=(cM.offset[1:length(cM.offset)-1]+cM.offset[2:length(cM.offset)])/2,
        labels=c(1:(POSITIONOFXCHROMOSOME-1),"X"),lwd=opt$axeswidth)
  axis(2, at=(bp.offset[1:length(bp.offset)-1]+bp.offset[2:length(bp.offset)])/2,
        labels=c(1:(POSITIONOFXCHROMOSOME-1),"X"),lwd=opt$axeswidth)

  if (!is.null(opt$legend)) {
     if (!is.null(opt$verbose)) cat("displaying legend.\n")
     steps<-45
     p<-par("mar")
     p[2]<-0;p[4]<-0
     if (!is.null(opt$verbose)) cat("-a.\n")
     cols<-color.palette(steps)
     if (opt$display %in% c("p.value","P value","P-value","p value","p-value","pvalue","Pvalue")) {
	cols<-rev(cols)
     }
     by=(selected.qtl.max-selected.qtl.min)/(steps-1)
     if (!is.null(opt$verbose)) {
	cat("a.\n")
	cat("min=",selected.qtl.min,"  max=",selected.qtl.max,"  by=",by,"\n")
     }
     y<-seq(from=selected.qtl.min,to=selected.qtl.max,by=by)
     if (!is.null(opt$verbose)) cat("b.\n")
     image(x=1:1,y=y,z=matrix(1:steps,1,steps),ylab="",xlab="",col=cols,add=FALSE)
  }

}

if(is.null(opt$interactive)) {
	dev.off()
}
