
TEMPLATEWARNINGHASH

doc <- "

=head1 NAME

analyseCorrelationForMarkers.R - collection of functions to investigate a change in the correlation of genes because of some marker

=head1 SYNOPSIS

plotExpr

plotExprSamples

plotExprPairs

analyzeclusters - main function for the investigation of the data

evalresiduals

find.best.markers

=head1 DESCRIPTION

This function defines a series of then global variables that
it needs for its analysis.
The load.data.R and maxcminc.R files needs to be sourced
prior to this file.


To include these functions

source('BASEDIR/scripts/analyses/R/load.data.R')

=cut

"


##### Extracting values
# Initialisation of chromosomes, cMorgan distances and the expression values

data.expression <- load.data("expression")
expr <- data.expression$numeric  # probes x individuals
exprrownames <- rownames(expr)

quandata <- load.data("genotypes")
# Look for marker data on chromosomes
chromos <- quandata$chromosomes
chromnames <- unique(chromos)
# Look for cMorgan distances on markers
cmorgan <- quandata$cMorgan
# get genotypes in same orientation
marker <- t(adjust.individuals.data.to.expressionData(data.expression,individualsData=quandata))
# Extract marker names
markerrownames <- rownames(marker)
# and analogously for clinical phenotypes
clinical <- t(adjust.individuals.data.to.expressionData(data.expression,individualsData=load.data("scores")))

# Remove the first two lines (chromos and cmorgan)
#quan <- apply(quandata[,3:dim(quandata)[2]], c(1, 2), as.numeric)
#cat("Loaded quantitative data\n")
#cat(dim(quan)); cat("\n")


doc <- "

=head2 Functions of interest for this script only

=over 4

=item plotExpr

Plot some expression samples

=cut

"
plotExpr <- function(expr, ch=c(1,2),...) {
  xlab=paste("Probeset",rownames(expr)[ch[1]],sep=": ")
  ylab=paste("Probeset",rownames(expr)[ch[2]],sep=": ")
  plot(t(expr[ch[1],]), t(expr[ch[2],]), xlab=xlab, ylab=ylab)
}


doc <- "

=item plotExprSamples

a routine of some value for interim evaluation while developing
Randomly take n samples of expression pairs and plot them one after another

To invoke it, try
 plotExprSamples(expr)

=cut

"

plotExprSamples <- function(expr, n = 20) {
  p<-par("ask")
  par("ask"=T)
  for (i in 1:n) {
    ch <- sample(1:dim(expr)[1], 2, replace=F)
    cat(ch); cat("\n")
    plotExpr(expr, ch)
  }
  par("ask"=p)
}

doc <- "

=item plotExprPairs

a routine of some value for interim evaluation while developing
Randomly take n samples of expression pairs (with p elements) and plot them one after another

=cut

"

plotExprPairs <- function(expr, n = 20, p = 3) {
  a<-par("ask")
  par("ask"=T)
  cat("Selecting ",p," probes to compare all against all.\n")
  for (i in 1:n) {
    ch <- sample(1:dim(expr)[1], p, replace=F)
    cat(ch); cat("\n")
    pairs(t(expr[ch,]))
  }
  par("ask"=a)
}


doc<- "

=item getClinical(covar)

Extract the EAE values and corresponding cols

"

getClinical <- function(covar=rownames(clinical)[2]) {
  phenv <- as.numeric(clinical[covar,])
  notna <- which(!is.na(phenv))
  val <- phenv[notna]
  val[val == 0] <- -1
  return(list(values=val, notna=notna, covar=covar))
}
eae <- getClinical()



library(grDevices) # qhull

doc <- "

=item analyzeclusters

Analyze clusters on pairs of expressions by marker values
e1 and e2 are indices of expression data rows, m is the marker index
draw is a boolean and activates the graphical output

=cut

"


analyzeclusters <- function(
			e1,
			e2,
			m=NULL,
			draw=F,
			verbose=FALSE,
			phen=NULL,
                        hull.lwd=3, hull.lty="dotted",
                        axes.colour="red", axes.linewidth=3, axes.linetype="solid",
			mean.pch=8, mean.cex=2,
			individuals.pch=22,
			individuals.cex=1,
			groups.col=c("red","green","gray"),
			label.individuals=T,
			selection_xaxis="gene",
			selection_yaxis="gene",
			selection_shape="phen",
			selection_colour="marker"
) {

  # get expression data (and make them columns)
  ed <- t(expr[c(e1, e2), ])
  # get marker data
  if (is.null(m)) {
  	m<-find.best.markers(e1,e2,verbose=verbose)
  }

  md <- marker[m,]
  if (length(md)>nrow(ed)) {
     cat("Dimension of marker data: "); print(dim(md))
     stop("Number of markers (",length(md),") and number of individuals with trait (",nrow(ed),") differ.\n")
  }

  group.list<-list(
    "0"=c("0",0," 0"),
    "1"=c("1",1," 1"),
    "2"=c("2",2," 2"),
    "2"=c("3",3," 3"),
    "A"=c("A"," A"),
    "H"=c("H"," H"),
    "B"=c("B"," B")
  )

  group.results<-list(
   "NA"=rep(T,length(md))
  )
  cat("Values in genotypes:  "); cat(paste("'",paste(unique(md),collapse=",",sep=""),"'\n",sep=""))
  for(n in names(group.list)) {
     if (is.na(n)) n<-"NA"
     v<-group.list[[n]]
     m<-(md %in% v)
     if (sum(m)>0) {
       group.results[[n]]<-m
       group.results[["NA"]][m]<-F
     }
  }

  cat("Available groups: "); print(paste(names(group.results),collapse=","))

  #if (length(pindices) == 0 || length(nindices) == 0) {
  #  message("analyzeclusters(",e1,",",e2,",",m,") :  problem with length(pindices)==",length(pindices)," and length(nindices)==",length(nindices),".\n")
  #  return(0)
  #}


  # evaluate the markerwise (classwise) means

  if (verbose) cat("Determining means for group ...\n",sep="")
  group.means<-list()
  for(n in names(group.results)) {
     if (verbose) cat("                          ...'",n,"'\n",sep="")
     group.means[[n]]<-colMeans(ed[group.results[[n]],,drop=F])
  }

  # if drawing is activated
  if (draw) {

    cat("\n\n*\n* Drawing \n*\n\n")

    # set color vector
    col <- rep("gray", length(md))
    col.list<-rainbow(length(group.means))
    names(col.list)<-names(group.means)
    for(n in names(group.means)) {
        col[ group.results[[n]] ] <- col.list[n]
    }

    if (verbose) cat("assigned all colours\n")

    xlab <- paste("Probeset", e1, sep=" ")
    ylab <- paste("Probeset", e2, sep=" ")
    sub <- paste("Marker ", if(is.character(m)) {m} else {markerrownames[m]}, sep="")
    #pch <- rep(individuals.pch, length(col))
    pch <- rep(22, length(col))
    if (!is.null(phen)) {
    	p.factors<-as.factor(phen$values)
	pch[phen$notna]<-20+sapply(phen$values,function(X){which(X==unique(phen$values))})
    	pch[naindices] <- 20
    }
    #pch[naindices] <- 20
    plot(x=ed, col=col, pch=pch, cex=individuals.cex, xlab=xlab, ylab=ylab, sub=sub, xaxt="n", yaxt="n")
    axis(1,col=axes.colour,lwd=axes.linewidth,lty=axes.linetype)
    axis(2,col=axes.colour,lwd=axes.linewidth,lty=axes.linetype)

    to.print<-NULL
    for (n in names(group.results)) {
        cat("Plotting group '",n,"'.\n",sep="")
    	ed.sub<-ed[group.results[[n]],]
	chu.indices<-chull(ed.sub)
	lines(ed.sub[c(chu.indices,chu.indices[1]),],lty=hull.lty,col=col.list[n],lwd=hull.lwd)
	to.print<-c(to.print,group.results[[n]][chu.indices])
    }
    for(n in names(group.means)) {
        points(t(group.means[[n]]), col = col.list[n], pch = mean.pch, cex = mean.cex)
    }
    #points(t(negm), col = "red", pch = mean.pch, cex = mean.cex)
    if (label.individuals) text(x=ed[to.print,],labels=rownames(ed)[to.print],cex=0.5,pos=4,offset=0.3)
  } else {
    # cat("\n\n*\n* Drawing was not activated.\n*\n\n")
  }
  return(group.means)
}


# Evaluate the differences of the means for each marker group
evalresiduals <- function(e1, e2, verbose=T, selection_xaxis="gene",selection_yaxis="gene",selection_shape="phen",selection_colour="marker") {
  sa<-sapply(markerrownames,function(m) {
      if (verbose) {
      	cat("evalresiduals: evaluation of ",m,"\n")
      }
      res <- analyzeclusters(e1,e2,m,draw=F)
      res.matrix<-matrix(NA,ncol=length(res),nrow=length(res))
      res.matrix.names<-names(res)
      colnames(res.matrix)<-rownames(res.matrix)<-res.matrix.names
      for(n1 in res.matrix.names) {
         for(n2 in names(res)) {
	    d<-(res[[n1]]-res[[n2]])
	    res.matrix[n1,n2]<-sqrt(sum(d^2))
	 }
      }
      if (verbose) print(res.matrix)
      return(max(res.matrix,na.rm=T))
  })
  if (verbose) {cat("dim(sa): "); print(dim(sa))}
  #geom.diff <- sqrt(colSums(sa[1:2,] - sa[3:4,])^2)
  #names(geom.diff)<-colnames(sa)

  return(sa)
}

 
find.best.markers <- function(e1, e2,verbose=FALSE) {
  m<-evalresiduals(e1,e2, verbose=verbose)
  m.best<-maxc(m)
  return(names(m)[m.best])
}

