#!/usr/bin/env r

doc<-"

=head1 NAME

createVenn.R - prepare Venn diagrams for traits shared between covariates

=head1 SYNOPSIS

createVenn.R [options]

or to be sourced from within an R shell

=head1 DESCRIPTION

=head1 OPTIONS

=over 4

=item verbose

=item help

=item MeanMin minimalExpressionLevel

only traits with an expression level higher or equal to the value denoted will be included in the analysis

=item LODmin minimalLODscore

only traits with a LOD score of at least the value denoted will be included in the analysis

=item cisDistMax maximalDistanceFromPeak

for being accepted as 'cis', the distance of the peak from the location of the gene must be with in that denoted region, defaulting to 2*10^7 .

=item interactive

rather than dumping an image to a file, specified by '--output', the result can be analysed interactively with the R shell . This is useful only when sourcing the script from within an R shell

=item format <png|jpeg|pdf>

=item covariates

list of covariates to be included 

=item output

complete path to file to include the resulting image, without any .jpeg etc suffix, please. There are multiple files to be created, each will receive its distinguished filename suffix:

=over 8

=item _all

overlap of traits between covariates - no additional selection performed

=back

=back


=head1 AUTHORS

Ann-Kristin Grimm <grimm@inb.uni-luebeck.de>,
Steffen Moeller <moeller@inb.uni-luebeck.de>,

=head1 COPYRIGHT

University of LE<uuml>beck, Germany, 2009

=cut

"

library(RMySQL)
library(getopt)

library(gplots) # for Venn diagrams

# cat("I was here 0.\n")

opt = getopt(matrix(c(
    'verbose'    , 'v', 2, "integer",
    'help'       , 'h', 0, "logical",
    'MeanMin'    , 'm', 1, "double",
    'LODmin'     , 'l', 1, "double",
    'cisDistMax' , 's', 1, "integer",
    'interactive', 'i', 0, "logical",
    'format'     , 'f', 1, "character",
    'covariates' , 'c', 1, "character",
    'output'     , 'o', 1, "character"
   ),ncol=4,byrow=TRUE),
   debug=TRUE)

if (is.null(opt$LODmin)) {
	opt[["LODmin"]] <- 3.5
	if (!is.null(opt$verbose)) cat("Setting default LODmin to ",opt$LODmin,"\n");
}

if (is.null(opt$cisDistMax)) {
	opt[["cisDistMax"]] <- 20*1000*1000
	if (!is.null(opt$verbose)) cat("Setting default cisDistMax to ",opt$cisDistMax,"\n");
}

# for manual interaction in shell: 
# con <- dbConnect(MySQL(),user="qtl", password="", dbname="eQTL_Stockholm", host="pc15.inb.uni-luebeck.de")

con <- dbConnect(MySQL(),user="DATABASEEQTLUSER", password="", dbname="DATABASEEQTLNAME", host="DATABASEHOSTLOCAL")

#covariates<-c('','eae_add','sud_add','dud_add','wl0_add','D12G1_add','D12G2B_add','D12G2C_add','D35G1_add','D35G2B_add','D35G2C_add','t12p_add','t35p_add')
if (is.null(opt$covariates)) {
	cat("Falling back to default covariates.\n")
	covariates<-c('eae_add','sud_add','dud_add','wl0_add','D12G1_add')
} else if (5<length(covariates)) {
	q(status=1);
} else {
	covariates <- opt$covariates
}

cat(paste("Working with the following covariates: ",paste(covariates, collapse="; "),"\n",sep=""))

q<-paste( "SELECT Locus, Trait, covariates, chromosome, cis, cis_dist,cMorgan_Peak ",
          "  FROM qtl JOIN trait ON trait_id=Trait JOIN locus ON locus.Name=qtl.Locus ",
	  " WHERE covariates in ('",
	  paste(covariates,collapse="','",sep=""),
	  "') and ((cis=1 and cis_dist>",opt$cisDistMax,") or cis=0)")
if (!is.null(opt$LODmin)) {
	q<-paste(q," AND LOD >= ",opt$LODmin,sep="")
}
if (!is.null(opt$LODmax)) {
	q<-paste(q," AND LOD <= ",opt$LODmax,sep="")
}
if (!is.null(opt$MeanMin)) {
	q<-paste(q," AND mean >= ",opt$MeanMin,sep="")
}
if (!is.null(opt$MeanMax)) {
	q<-paste(q," AND mean <= ",opt$MeanMax,sep="")
}
cat("Query: ",q,"\n")
rs<-dbGetQuery(con,q)


# loc.trait has unique identifiers for all trait-covariate pairs
loc.trait<-apply(rs,1,function(x){return(paste(x[1],x[2],sep="_"))})

# loc.trait.covariate is a list of these traits, assigned to each covariate
loc.trait.covariate<-sapply(covariates,function(covar){
	return(loc.trait[rs[,3]==covar])
},USE.NAMES=TRUE)

#
#	V E N N  -  A L L
#

prepareOutput <-function(filename) {
	if (is.null(opt$interactive)) {
		if (is.null(opt$format) || "png" == opt$format) {
			png(opt[["output"]],width=width.pixel,height=height.pixel)
		}
		else if ("pdf" == opt$format) {
			pdf(opt[["output"]],width=width.inch,height=height.inch)
		}
		else if ("jpg" == opt$format  || "jpeg" == opt$format) {
			jpg(opt[["output"]],width=width.pixel,height=height.pixel)
		}
		else if ("gif" == opt$format) {
			jpg(opt[["output"]],width=width.pixel,height=height.pixel)
		}
		else {
			cat("Unknown format ",opt$format,"\n")
			q(status=1);
		}
	}
}

prepareOutput(paste(opt$output,"_all.",opt$format,sep=""))

venn(loc.trait.covariate)

if(is.null(opt$interactive)) {
	dev.off()
}

rs.map<-dbGetQuery(con, "SELECT marker, cmorgan_rqtl, chr, bp FROM map ORDER BY chr,cmorgan_rqtl")
rs.map.cM2bp <- sapply(unique(rs.map[,"chr"]),function(X){
				#print(paste("Chr:",X))
				subset<-(rs.map[,"chr"]==X)
				#print(which(subset))
				data.pairs.relevant<-rs.map[subset,c("cmorgan_rqtl","bp")]
				#print(data.pairs.relevant)
				approxfun(data.pairs.relevant)
			},USE.NAMES=TRUE)

rs.map.bp2cM <- sapply(unique(rs.map[,"chr"]),function(X){
				#print(paste("Chr:",X))
				subset<-(rs.map[,"chr"]==X)
				#print(which(subset))
				data.pairs.relevant<-rs.map[subset,c("bp","cmorgan_rqtl")]
				#print(data.pairs.relevant)
				approxfun(data.pairs.relevant)
			},USE.NAMES=TRUE)


dbDisconnect(con)
#read disease qtl

if (FALSE) {
	disease_qtl<-read.table("/nfshome/grimm/gitEqtlRepo/data/xls/DAPVGdisease_loci_T_Olsson_090320.csv", sep=",",header=T)
	isInQTL<-function(pos,chr,disease_qtl){
		disease_qtl_chr<-disease_qtl[which(disease_qtl$RNO==chr),]
		positions<-strsplit(as.character(disease_qtl_chr[,"Mb.positions"]),"-")
		value<-unlist(lapply(positions,function(x){return(as.numeric(x[1])*1000000<=pos && pos<=as.numeric(x[2])*1000000)}))
		if(sum(value)>=1){
			return(1)
		}
		return(0)
	}
}

# For testing:
# disease_qtl<-dbGetQuery(con, paste("SELECT name, chr, start_bps, stop_bps, species", "FROM qtl.eae_qtl", "WHERE species='Rattus_norvegicus'", "AND start_bps IS NOT NULL and stop_bps IS NOT NULL",sep=" "));

disease_qtl<-dbGetQuery(con, paste("SELECT name, chr, start_bps, stop_bps, species",
                                   "FROM qtl.eae_qtl",
				   "WHERE species='ENSEMBLSPECIESSEARCHURL'",
				     "AND start_bps IS NOT NULL and stop_bps IS NOT NULL",sep=" "));
isInQTL<-function(pos,chr) {
	s<-disease_qtl[,"chr"]==chr;
	a<-(disease_qtl[,"start_bps"]<=pos)
	b<-(disease_qtl[,"stop_bps"]>=pos)
	r<-s&a&b
	return(any(r))
}


# Transformation of locations to such of neighbouring markers
marker.trait<-NULL
for (i in 1:nrow(rs)) {
	cat(i,"\n") ; chr<-rs$chromosome[i] ; locus<-rs$Locus[i] ; cm<-rs$cMorgan_Peak[i] ; bp<-rs.map.cM2bp[[chr]](cm) ; inDiseaseQTL<-isInQTL(bp,chr)
	if (1 == sum(rs.map$marker==rs$Locus[i])) {         # The locus is assigned directly to a marker
		pos<-which(rs.map$marker==rs$Locus[i])
		if (pos<nrow(rs.map) && rs.map$chr[pos+1]==rs.map$chr[pos]) {
			marker.trait.value<-c(paste(rs$Locus[i],rs.map$marker[pos+1],rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		} else {
			marker.trait.value<-c(paste(rs$Locus[i],"end",rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		}
		if(is.null(marker.trait)) {
			marker.trait<-matrix(marker.trait.value,nrow=1)
			colnames(marker.trait)<-c("Marker-Trait","Covariates","InDiseaseQTL")
		} else { marker.trait<-rbind(marker.trait,marker.trait.value) }

		if (pos>1 && rs.map$chr[pos-1]==rs.map$chr[pos]) {
			marker.trait.value<-c(paste(rs.map$marker[pos-1],rs$Locus[i],rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		} else {
			marker.trait.value<-c(paste("begin",rs$Locus[i],rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		}
		if(is.null(marker.trait)){ marker.trait<-marker.trait.value } else { marker.trait<-rbind(marker.trait,marker.trait.value) }
	} else if (0 == sum(rs.map$marker==rs$Locus[i])) {  # The locus is between two markers
		rs.map.chr<-rs.map[which(rs.map$chr==rs$chromosome[i]),]
		pos<-sum(rs.map.chr$cmorgan_rqtl<cm)
		if(pos==0){
			marker.trait.value<-c(paste("begin",rs.map.chr$marker[1],rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		}
		else if(pos==nrow(rs.map.chr)){
			marker.trait.value<-c(paste(rs.map.chr$marker[nrow(rs.map.chr)],"end",rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		}
		else{
			marker.trait.value<-c(paste(rs.map.chr$marker[pos],rs.map.chr$marker[pos+1],rs$Trait[i],sep="_"),rs$covariates[i],inDiseaseQTL)
		}
		if(is.null(marker.trait)){ marker.trait<-marker.trait.value } else{ marker.trait<-rbind(marker.trait,marker.trait.value) }
	} else {
		cat("E: Internal error - locus is assigned to two markers - impossible.\n")
	}
}



marker.trait.covariate<-sapply(covariates,function(covar){
		return(marker.trait[marker.trait[,2]==covar,])
	},USE.NAMES=TRUE)

prepareOutput(paste(opt$output,"_marker_trait.",opt$format,sep=""))
venn(list(D12G1=D12G1[,1],D12G2B=D12G2B[,1],D12G2C=D12G2C[,1],t12p=t12p[,1]),label=list("1111"=paste("In QTL:",sum(as.numeric(D12[,3])),sep=" ")))
dev.off()


png("VennDiagrams/Trans/DiseaseCovariates_intersection_trans.png")
venn(list(eae=eae[,1],sud=sud[,1],dud=dud[,1],wl0=wl0[,1],IgG=Dall[,1]),label=list("11111"=paste("In QTL:",sum(as.numeric(eae_all[,3])),sep=" ")))
dev.off()
all<-none[none[,1] %in% eae_all[,1],]
none_single<-none[!(none[,1] %in% eae_all[,1]),]
eae_all_single<-eae_all[!(eae_all[,1] %in% none[,1]),]

png("VennDiagrams/Trans/DiseaseCovariates_transcript_intersection_trans.png")
venn(list(transcript=none[,1],disease_covariates=eae_all[,1]),label=list("11"=paste("In QTL:",sum(as.numeric(all[,3])),sep=" "),"10"=paste("In QTL:",sum(as.numeric(none_single[,3])),sep=" "),"01"=paste("In QTL:",sum(as.numeric(eae_all_single[,3])),sep=" ")))
dev.off()

